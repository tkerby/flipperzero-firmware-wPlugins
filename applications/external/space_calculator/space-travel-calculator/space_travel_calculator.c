#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <input/input.h>
#include <stdlib.h>
#include <math.h>

/* generated by fbt from .png files in images folder */
#include <space_travel_calculator_icons.h>

// Physical constants - all explicitly double to avoid promotion warnings
static const double MU_SUN = 1.32712440018e20; // Standard gravitational parameter (m³/s²)
static const double AU_TO_KM = 149597870.7; // Astronomical Unit in kilometers
static const double SECONDS_PER_DAY = 86400.0; // Seconds in a day
static const double PI_CONST = 3.14159265358979323846; // Pi constant
static const double TWO_PI = 6.28318530717958647692; // 2 * Pi
static const double PI_OVER_180 = 0.01745329251994329577; // Pi / 180
static const double INV_PI_OVER_180 = 57.2957795130823208768; // 180 / Pi

// Additional double constants to avoid float promotion
static const double ZERO = 0.0;
static const double ONE = 1.0;
static const double TWO = 2.0;
static const double HALF = 0.5;
static const double FIFTEEN = 15.0;
static const double TWENTY = 20.0;
static const double TEN = 10.0;
static const double THOUSAND = 1000.0;
static const double ONE_EIGHTY = 180.0;
static const double THREE_SIXTY = 360.0;
static const double TWENTY_TWO_HALF = 22.5;
static const double FORTY_FIVE = 45.0;

// Display constants
#define SCREEN_WIDTH     128
#define SCREEN_HEIGHT    64
#define ORBIT_CENTER_X   64
#define ORBIT_CENTER_Y   32
#define MAX_ORBIT_RADIUS 30

// Application state
typedef enum {
    VIEW_ORBIT,
    VIEW_DATA,
    VIEW_PHASE,
    VIEW_COUNT
} ViewMode;

typedef struct {
    const char* name;
    double period_days; // Orbital period in days
    double semi_major_au; // Semi-major axis in AU (or km for moons)
    double eccentricity; // Orbital eccentricity
    double start_angle_deg; // Starting angle at epoch
    int parent_body; // -1 for planets, planet_id for moons
    bool is_moon;
} CelestialBody;

typedef struct {
    double delta_v_total; // Total delta-v in km/s
    double flight_time_days; // Flight time in days
    double departure_angle; // Departure angle in degrees
    bool is_possible; // Whether transfer is possible
} TransferResult;

typedef struct {
    ViewMode current_view;
    int current_destination; // Index into destinations array
    int current_day; // Day of year (1-365)
    TransferResult current_transfer;
    bool needs_redraw;
} AppState;

// Celestial body database - pre-calculated AU conversions to avoid runtime division
static const CelestialBody destinations[] = {
    // Planets (distances in AU)
    {"MARS", 687.0, 1.524, 0.0934, 30.0, -1, false},
    {"VENUS", 225.0, 0.723, 0.0068, 45.0, -1, false},
    {"MERCURY", 88.0, 0.387, 0.2056, 0.0, -1, false},
    {"JUPITER", 4333.0, 5.203, 0.0484, 120.0, -1, false},

    // Earth's Moon (pre-calculated: 384400 km / 149597870.7 km/AU = 0.00256955529 AU)
    {"MOON", 27.3, 0.00256955529, 0.0549, 0.0, 2, true},

    // Jupiter's Major Moons (pre-calculated AU values)
    {"EUROPA", 3.55, 0.00448558524, 0.009, 90.0, 3, true}, // 671034 km
    {"GANYMEDE", 7.15, 0.00715518206, 0.0013, 45.0, 3, true}, // 1070400 km  
    {"IO", 1.77, 0.00281889039, 0.0041, 0.0, 3, true}, // 421700 km
    {"TITAN", 15.9, 0.00816742908, 0.0288, 120.0, 4, true}, // 1221830 km (Saturn's moon)
};

static const int DESTINATION_COUNT = sizeof(destinations) / sizeof(destinations[0]);

// Earth orbital parameters
static const CelestialBody earth = {"EARTH", 365.0, 1.0, 0.0167, 0.0, -1, false};

// Calculate planetary position at given day
static double calculate_orbital_position(const CelestialBody* body, int day_of_year) {
    // Mean anomaly based on time since epoch
    double mean_anomaly = (TWO_PI * (double)day_of_year) / body->period_days;

    // Add starting position offset
    double start_radians = body->start_angle_deg * PI_OVER_180;
    double position = mean_anomaly + start_radians;

    // Keep angle in 0-2π range
    while(position > TWO_PI)
        position -= TWO_PI;
    while(position < ZERO)
        position += TWO_PI;

    return position;
}

// Calculate Hohmann transfer delta-v
static double calculate_hohmann_delta_v(double r1_au, double r2_au) {
    // Convert AU to meters
    double r1 = r1_au * AU_TO_KM * THOUSAND;
    double r2 = r2_au * AU_TO_KM * THOUSAND;

    // First burn: enter transfer orbit
    double v1 = sqrt(MU_SUN / r1);
    double vt1 = sqrt(MU_SUN / r1) * sqrt(TWO * r2 / (r1 + r2));
    double delta_v1 = fabs(vt1 - v1);

    // Second burn: circularize at destination
    double v2 = sqrt(MU_SUN / r2);
    double vt2 = sqrt(MU_SUN / r2) * sqrt(TWO * r1 / (r1 + r2));
    double delta_v2 = fabs(v2 - vt2);

    // Convert to km/s and return total
    return (delta_v1 + delta_v2) / THOUSAND;
}

// Calculate transfer time (half period of elliptical transfer orbit)
static double calculate_transfer_time(double r1_au, double r2_au) {
    double r1 = r1_au * AU_TO_KM * THOUSAND;
    double r2 = r2_au * AU_TO_KM * THOUSAND;
    double a_transfer = (r1 + r2) / TWO;
    double time_seconds = PI_CONST * sqrt(pow(a_transfer, 3.0) / MU_SUN);
    return time_seconds / SECONDS_PER_DAY; // Convert to days
}

// Calculate transfer window quality based on planetary positions
static TransferResult calculate_transfer(const CelestialBody* destination, int day_of_year) {
    TransferResult result = {0};

    // Get planetary positions
    double earth_angle = calculate_orbital_position(&earth, day_of_year);
    double dest_angle = calculate_orbital_position(destination, day_of_year);

    // Calculate phase angle (relative position)
    double phase_angle = dest_angle - earth_angle;
    while(phase_angle > PI_CONST)
        phase_angle -= TWO_PI;
    while(phase_angle < -PI_CONST)
        phase_angle += TWO_PI;

    // Calculate basic Hohmann transfer
    result.delta_v_total =
        calculate_hohmann_delta_v(earth.semi_major_au, destination->semi_major_au);
    result.flight_time_days =
        calculate_transfer_time(earth.semi_major_au, destination->semi_major_au);

    // Phase angle penalty - transfers work best at specific alignments
    double ideal_phase = 0.0; // Simplified - real calculation is more complex
    double phase_penalty = fabs(phase_angle - ideal_phase);

    // Apply phase penalty to delta-v (poor alignment = higher energy needed)
    result.delta_v_total *= (ONE + phase_penalty * HALF);

    // Calculate departure angle (simplified)
    result.departure_angle = earth_angle * INV_PI_OVER_180;
    while(result.departure_angle < ZERO)
        result.departure_angle += THREE_SIXTY;
    while(result.departure_angle >= THREE_SIXTY)
        result.departure_angle -= THREE_SIXTY;

    // Determine if transfer is practical
    result.is_possible = (result.delta_v_total < FIFTEEN); // Arbitrary cutoff for "practical"

    return result;
}

// Get arrow symbol for burn direction - using ASCII characters
static const char* get_burn_direction_arrow(double angle_degrees) {
    // Convert to 8 cardinal directions
    int octant = (int)((angle_degrees + TWENTY_TWO_HALF) / FORTY_FIVE) % 8;

    static const char* arrows[] = {">", "/", "^", "\\", "<", "/", "v", "\\"};
    return arrows[octant];
}

// Draw orbital diagram view
static void draw_orbit_view(Canvas* canvas, AppState* state) {
    // Clear screen
    canvas_clear(canvas);
    canvas_set_color(canvas, ColorBlack);

    // Draw title
    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str(canvas, 2, 10, "ORBIT VIEW");

    // Draw destination name
    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str(canvas, 2, 22, destinations[state->current_destination].name);

    // Draw sun at center
    canvas_draw_disc(canvas, ORBIT_CENTER_X, ORBIT_CENTER_Y, 2);

    // Draw Earth orbit
    canvas_set_color(canvas, ColorBlack);
    canvas_draw_circle(canvas, ORBIT_CENTER_X, ORBIT_CENTER_Y, 15);

    // Draw destination orbit
    const CelestialBody* dest = &destinations[state->current_destination];
    double radius_scale = FIFTEEN * sqrt(dest->semi_major_au); // Scale by sqrt for visibility
    int dest_radius = (int)radius_scale;
    if(dest_radius > MAX_ORBIT_RADIUS) dest_radius = MAX_ORBIT_RADIUS;
    if(dest_radius < 18) dest_radius = 18; // Minimum separation from Earth

    canvas_draw_circle(canvas, ORBIT_CENTER_X, ORBIT_CENTER_Y, dest_radius);

    // Calculate and draw planetary positions
    double earth_angle = calculate_orbital_position(&earth, state->current_day);
    double dest_angle = calculate_orbital_position(dest, state->current_day);

    // Earth position
    double earth_x_calc = FIFTEEN * cos(earth_angle);
    double earth_y_calc = FIFTEEN * sin(earth_angle);
    int earth_x = ORBIT_CENTER_X + (int)earth_x_calc;
    int earth_y = ORBIT_CENTER_Y + (int)earth_y_calc;
    canvas_draw_disc(canvas, earth_x, earth_y, 1);
    canvas_draw_str(canvas, earth_x - 3, earth_y - 5, "E");

    // Destination position
    double dest_x_calc = (double)dest_radius * cos(dest_angle);
    double dest_y_calc = (double)dest_radius * sin(dest_angle);
    int dest_x = ORBIT_CENTER_X + (int)dest_x_calc;
    int dest_y = ORBIT_CENTER_Y + (int)dest_y_calc;
    canvas_draw_disc(canvas, dest_x, dest_y, 1);

    // Draw transfer ellipse if possible
    if(state->current_transfer.is_possible) {
        // Simple ellipse approximation - draw line between planets
        canvas_draw_line(canvas, earth_x, earth_y, dest_x, dest_y);

        // Draw burn direction arrow
        const char* arrow = get_burn_direction_arrow(state->current_transfer.departure_angle);
        canvas_draw_str(canvas, earth_x + 5, earth_y, arrow);
    } else {
        canvas_draw_str(canvas, 2, 60, "NO PATH");
    }

    // Draw day indicator
    char day_str[16];
    snprintf(day_str, sizeof(day_str), "DAY: %d", state->current_day);
    canvas_draw_str(canvas, 80, 60, day_str);
}

// Draw data view
static void draw_data_view(Canvas* canvas, AppState* state) {
    canvas_clear(canvas);
    canvas_set_color(canvas, ColorBlack);

    // Draw title
    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str(canvas, 2, 10, "DATA VIEW");

    // Draw destination
    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str(canvas, 2, 22, destinations[state->current_destination].name);

    if(state->current_transfer.is_possible) {
        char line[32];

        // Launch day
        snprintf(line, sizeof(line), "LAUNCH: %d", state->current_day);
        canvas_draw_str(canvas, 2, 34, line);

        // Flight time
        snprintf(line, sizeof(line), "FLIGHT: %dd", (int)state->current_transfer.flight_time_days);
        canvas_draw_str(canvas, 2, 44, line);

        // Delta-v
        snprintf(line, sizeof(line), "BURN: %.1f km/s", state->current_transfer.delta_v_total);
        canvas_draw_str(canvas, 2, 54, line);

        // Burn direction
        const char* arrow = get_burn_direction_arrow(state->current_transfer.departure_angle);
        snprintf(
            line, sizeof(line), "DIR: %s%.0f°", arrow, state->current_transfer.departure_angle);
        canvas_draw_str(canvas, 2, 64, line);
    } else {
        canvas_draw_str(canvas, 2, 40, "TRANSFER");
        canvas_draw_str(canvas, 2, 50, "IMPRACTICAL");
    }
}

// Draw phase view
static void draw_phase_view(Canvas* canvas, AppState* state) {
    canvas_clear(canvas);
    canvas_set_color(canvas, ColorBlack);

    // Draw title
    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str(canvas, 2, 10, "PHASE VIEW");

    // Draw destination
    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str(canvas, 2, 22, destinations[state->current_destination].name);

    // Calculate phase angle
    double earth_angle = calculate_orbital_position(&earth, state->current_day);
    double dest_angle =
        calculate_orbital_position(&destinations[state->current_destination], state->current_day);
    double phase_angle = dest_angle - earth_angle;

    // Normalize to -180 to +180 degrees
    phase_angle = phase_angle * INV_PI_OVER_180;
    while(phase_angle > ONE_EIGHTY)
        phase_angle -= THREE_SIXTY;
    while(phase_angle < -ONE_EIGHTY)
        phase_angle += THREE_SIXTY;

    // Draw phase information
    char line[32];
    snprintf(line, sizeof(line), "PHASE: %.0f°", phase_angle);
    canvas_draw_str(canvas, 2, 34, line);

    // Draw relative positions as a simple diagram
    canvas_draw_str(canvas, 2, 46, "RELATIVE POS:");

    // Earth (always at reference position)
    canvas_draw_disc(canvas, 30, 56, 2);
    canvas_draw_str(canvas, 25, 65, "E");

    // Destination relative to Earth
    double phase_rad = phase_angle * PI_OVER_180;
    double rel_x_calc = TWENTY * cos(phase_rad);
    double rel_y_calc = TEN * sin(phase_rad);
    int rel_x = 30 + (int)rel_x_calc;
    int rel_y = 56 + (int)rel_y_calc;
    canvas_draw_disc(canvas, rel_x, rel_y, 1);
    canvas_draw_str(canvas, rel_x - 2, rel_y + 8, "D");

    // Connection line
    canvas_draw_line(canvas, 30, 56, rel_x, rel_y);
}

// Main draw callback
static void draw_callback(Canvas* canvas, void* ctx) {
    AppState* state = (AppState*)ctx;

    switch(state->current_view) {
    case VIEW_ORBIT:
        draw_orbit_view(canvas, state);
        break;
    case VIEW_DATA:
        draw_data_view(canvas, state);
        break;
    case VIEW_PHASE:
        draw_phase_view(canvas, state);
        break;
    default:
        break;
    }
}

// Input callback
static void input_callback(InputEvent* input_event, void* ctx) {
    furi_assert(ctx);
    FuriMessageQueue* event_queue = ctx;
    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

// Main application entry point
int32_t space_travel_calculator_app(void* p) {
    UNUSED(p);

    // Initialize application state
    AppState* state = malloc(sizeof(AppState));
    state->current_view = VIEW_ORBIT;
    state->current_destination = 0; // Start with Mars
    state->current_day = 147; // Optimal Mars transfer window
    state->needs_redraw = true;

    // Calculate initial transfer
    state->current_transfer =
        calculate_transfer(&destinations[state->current_destination], state->current_day);

    // Set up GUI
    Gui* gui = furi_record_open(RECORD_GUI);

    // Create event queue
    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    // Set up viewport
    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, draw_callback, state);
    view_port_input_callback_set(view_port, input_callback, event_queue);

    // Register viewport with GUI
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    // Main event loop
    InputEvent event;
    bool running = true;

    while(running) {
        if(furi_message_queue_get(event_queue, &event, 100) == FuriStatusOk) {
            if(event.type == InputTypePress || event.type == InputTypeRepeat) {
                switch(event.key) {
                case InputKeyBack:
                    running = false;
                    break;

                case InputKeyLeft:
                    // Previous day
                    state->current_day--;
                    if(state->current_day < 1) state->current_day = 365;
                    state->current_transfer = calculate_transfer(
                        &destinations[state->current_destination], state->current_day);
                    state->needs_redraw = true;
                    break;

                case InputKeyRight:
                    // Next day
                    state->current_day++;
                    if(state->current_day > 365) state->current_day = 1;
                    state->current_transfer = calculate_transfer(
                        &destinations[state->current_destination], state->current_day);
                    state->needs_redraw = true;
                    break;

                case InputKeyUp:
                    // Previous destination
                    state->current_destination--;
                    if(state->current_destination < 0)
                        state->current_destination = DESTINATION_COUNT - 1;
                    state->current_transfer = calculate_transfer(
                        &destinations[state->current_destination], state->current_day);
                    state->needs_redraw = true;
                    break;

                case InputKeyDown:
                    // Next destination
                    state->current_destination++;
                    if(state->current_destination >= DESTINATION_COUNT)
                        state->current_destination = 0;
                    state->current_transfer = calculate_transfer(
                        &destinations[state->current_destination], state->current_day);
                    state->needs_redraw = true;
                    break;

                case InputKeyOk:
                    // Cycle through views
                    state->current_view = (ViewMode)((state->current_view + 1) % VIEW_COUNT);
                    state->needs_redraw = true;
                    break;

                default:
                    break;
                }
            }
        }

        // Trigger redraw if needed
        if(state->needs_redraw) {
            view_port_update(view_port);
            state->needs_redraw = false;
        }
    }

    // Cleanup
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    furi_message_queue_free(event_queue);
    furi_record_close(RECORD_GUI);
    free(state);

    return 0;
}