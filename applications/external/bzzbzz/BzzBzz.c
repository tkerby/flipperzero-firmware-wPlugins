#include <furi.h>
#include <gui/gui.h>
#include <input/input.h>
#include <stdlib.h>
#include <dolphin/dolphin.h>
#include <notification/notification.h>
#include <notification/notification_messages.h>
#include <gui/elements.h>
#include <math.h>

/* generated by fbt from .png files in images folder */
#include <bzzbzz_icons.h>

// Game constants
#define PATTERN_LENGTH 5
#define VIBRATION_DURATION 10 // ms - extremely short vibration
#define PAUSE_DURATION_1 200 // ms - first possible pause duration
#define PAUSE_DURATION_2 500 // ms - second possible pause duration
#define PAUSE_DURATION_3 800 // ms - third possible pause duration
#define GAME_MESSAGE_DURATION 1000 // ms

// Game states
typedef enum {
    GameStateIdle,
    GameStateShowingPattern,
    GameStateWaitingForInput,
    GameStatePlaying
} GameState;

// Game context
typedef struct {
    Gui* gui;
    NotificationApp* notification;
    FuriMutex* mutex;

    // Game state
    uint32_t pattern[PATTERN_LENGTH - 1];  // Store timing intervals in ms (4 intervals for 5 vibrations)
    uint8_t current_input_index;
    uint32_t correct_in_a_row;
    uint32_t total_correct;
    uint32_t hi_score;             // Track highest streak achieved
    uint32_t pattern_start_time;  // To track when pattern started
    uint32_t last_input_time;     // To track last OK press
    uint32_t last_pattern_time;   // To track when pattern was last shown for timeout
    bool timeout_replay_occurred;  // Flag to track if timeout replay has already occurred since last user input
    uint32_t input_times[PATTERN_LENGTH];  // Store when user pressed OK (for evaluation after 5 presses)
    uint8_t pattern_reveal_index;  // Track which pattern element is currently being revealed
    bool pattern_revealed[PATTERN_LENGTH];  // Track which pattern elements have been revealed
    ViewPort* view_port;           // For immediate UI updates
    GameState state;

    // UI elements
    char status_text[64];
    float last_accuracy;  // Accuracy percentage of the last pattern match attempt
} VibrationGameContext;

// Input event structure
typedef struct {
    InputType type;
    InputKey key;
} GameInputEvent;

// Function declarations
static void vibration_game_render_callback(Canvas* canvas, void* ctx);
static void vibration_game_input_callback(InputEvent* input_event, void* ctx);
static void vibration_game_update_timer_callback(void* ctx);
static void play_vibration_pattern(VibrationGameContext* context);
static void reset_pattern_state(VibrationGameContext* context);
static void check_timeout_and_update(VibrationGameContext* context);

// Main application thread
int32_t bzzbzz_app(void* p) {
    UNUSED(p);

    VibrationGameContext* context = malloc(sizeof(VibrationGameContext));
    if (!context) {
        return -1;
    }

    // Initialize context
    context->current_input_index = 0;
    context->correct_in_a_row = 0;
    context->total_correct = 0;
    context->hi_score = 0;
    context->pattern_reveal_index = 0;
    for(int i = 0; i < PATTERN_LENGTH; i++) {
        context->pattern_revealed[i] = false;
    }
    context->last_pattern_time = 0;
    context->timeout_replay_occurred = false;

    // Seed the random number generator with current time
    srand(furi_get_tick());

    context->state = GameStateIdle;
    strcpy(context->status_text, "Press OK to start.");

    // Initialize GUI
    context->gui = furi_record_open(RECORD_GUI);
    context->notification = furi_record_open(RECORD_NOTIFICATION);
    context->mutex = furi_mutex_alloc(FuriMutexTypeNormal);

    // Setup GUI callbacks
    ViewPort* view_port = view_port_alloc();
    view_port_set_orientation(view_port, ViewPortOrientationHorizontal);
    view_port_draw_callback_set(view_port, vibration_game_render_callback, context);
    view_port_input_callback_set(view_port, vibration_game_input_callback, context);

    // Store view_port in context for immediate UI updates
    context->view_port = view_port;

    // Add view port to GUI
    gui_add_view_port(context->gui, view_port, GuiLayerFullscreen);

    // Main game loop
    FuriTimer* timer = furi_timer_alloc(vibration_game_update_timer_callback, FuriTimerTypePeriodic, context);
    furi_timer_start(timer, 500); // Check every 500ms for timeout

    // Wait for user to start the game
    while(1) { // Game runs indefinitely until back button is pressed
        furi_mutex_acquire(context->mutex, FuriWaitForever);

        if(context->state == GameStateIdle) {
            // Wait for user to press OK to start the game
        } else if(context->state == GameStateShowingPattern) {
            // Release mutex before playing vibration to avoid deadlock
            furi_mutex_release(context->mutex);
            // Wait 1 second before showing the pattern for a more relaxed experience
            furi_delay_ms(1000);
            // Show the pattern and then wait for input
            play_vibration_pattern(context);
            furi_mutex_acquire(context->mutex, FuriWaitForever);
            // Update state after playing the pattern and record start time for input
            context->pattern_start_time = furi_get_tick(); // Start timing from when pattern finishes
            context->last_pattern_time = context->pattern_start_time; // Record when pattern was shown
            context->last_input_time = context->pattern_start_time; // Reset timeout from now
            context->state = GameStateWaitingForInput;
            strcpy(context->status_text, "Repeat the pattern.");
        } else if(context->state == GameStateWaitingForInput) {
            // Wait for user input
        } else if(context->state == GameStatePlaying) {
            // Exit state - break the loop to exit the app
            furi_mutex_release(context->mutex);
            break;
        }

        furi_mutex_release(context->mutex);
        furi_delay_ms(100);
    }

    // Cleanup
    furi_timer_stop(timer);
    gui_remove_view_port(context->gui, view_port);
    view_port_free(view_port);
    furi_timer_free(timer);
    furi_mutex_free(context->mutex);
    furi_record_close(RECORD_GUI);
    furi_record_close(RECORD_NOTIFICATION);
    free(context);

    return 0;
}

// Render callback - draws the game UI
static void vibration_game_render_callback(Canvas* canvas, void* ctx) {
    VibrationGameContext* context = (VibrationGameContext*)ctx;

    furi_mutex_acquire(context->mutex, FuriWaitForever);

    // Clear canvas
    canvas_clear(canvas);

    if(context->state == GameStateIdle) {
        // Draw start.png image at full screen coordinates (0, 0)
        canvas_draw_icon(canvas, 0, 5, &I_start); // Full screen image

        // Draw start button in center
        elements_button_center(canvas, "Start");
    } else {
        // Draw game.png as background
        canvas_draw_icon(canvas, 0, 0, &I_game); // game.png as background

        // Draw labels: STEP at top, ACC% at middle, CURRENT at bottom (left aligned)
        canvas_set_font(canvas, FontSecondary);  // Regular font
        canvas_draw_str_aligned(canvas, 0, 0, AlignLeft, AlignTop, "STEP");
        canvas_draw_str_aligned(canvas, 0, 33, AlignLeft, AlignTop, "ACC%");
        canvas_draw_str_aligned(canvas, 128, 33, AlignRight, AlignTop, "BEST");
        canvas_draw_str_aligned(canvas, 128, 0, AlignRight, AlignTop, "SCORE");

        // Draw accuracy percentage in the middle left area
        char accuracy_text[16];
        snprintf(accuracy_text, sizeof(accuracy_text), "%02d", (int)context->last_accuracy);
        canvas_set_font(canvas, FontBigNumbers);  // Regular font
        canvas_draw_str_aligned(canvas, 0, 44, AlignLeft, AlignTop, accuracy_text);
        
        // Draw hi score in the top left corner in "xx" format
        char hi_score_text[16];
        snprintf(hi_score_text, sizeof(hi_score_text), "%02lu", context->hi_score);
        canvas_set_font(canvas, FontBigNumbers);  // Use smaller font
        canvas_draw_str_aligned(canvas, 128, 44, AlignRight, AlignTop, hi_score_text);

        // Draw current streak in the bottom left corner in "xx" format
        char streak_text[16];
        snprintf(streak_text, sizeof(streak_text), "%02lu", context->correct_in_a_row);
        canvas_set_font(canvas, FontBigNumbers);  // Use big number font
        canvas_draw_str_aligned(canvas, 128, 12, AlignRight, AlignTop, streak_text);

        // Draw analog speedometer-style indicator for current input progress
        // Center point at (16, 15)
        int center_x = 11;
        int center_y = 22;

        // Calculate angle based on current_input_index (0 to 5)
        // Step 0: hidden initially, Step 1: -180 degrees (6 o'clock)
        // Step 2: -135 degrees, Step 3: -90 degrees (9 o'clock),
        // Step 4: -45 degrees, Step 5: 0 degrees (12 o'clock) - stays until pattern done
        float angle_rad = 0.0f;
        bool draw_indicator = true;

        switch(context->current_input_index) {
            case 0: // Start at step 5 position initially
                angle_rad = 0.0f; // 0 degrees (12 o'clock)
                break;
            case 1: // -180 degrees - 6 o'clock
                angle_rad = -M_PI; // -180 degrees
                break;
            case 2: // -135 degrees - between 6 and 9 o'clock
                angle_rad = -3 * M_PI / 4.0f; // -135 degrees
                break;
            case 3: // -90 degrees - 9 o'clock
                angle_rad = -M_PI / 2.0f; // -90 degrees
                break;
            case 4: // -45 degrees - between 9 and 12 o'clock
                angle_rad = -M_PI / 4.0f; // -45 degrees
                break;
            case 5: // 0 degrees - 12 o'clock - stays until pattern done
                angle_rad = 0.0f; // 0 degrees
                break;
        }

        // Always draw the indicator (no hidden state)
        draw_indicator = true;

        // Draw the indicator line (1px thick, 3px long) only if it should be visible
        if(draw_indicator) {
            int line_length = 6; // Length of the indicator line
            int end_x = center_x + (int)(line_length * cosf(angle_rad));
            int end_y = center_y + (int)(line_length * sinf(angle_rad));

            // Draw a 1px thick line
            canvas_draw_line(canvas, center_x, center_y, end_x, end_y);
        }
    }

    furi_mutex_release(context->mutex);
}


// Input callback - handles button presses
static void vibration_game_input_callback(InputEvent* input_event, void* ctx) {
    VibrationGameContext* context = (VibrationGameContext*)ctx;

    furi_mutex_acquire(context->mutex, FuriWaitForever);

    if(input_event->type == InputTypeShort) {
        if(input_event->key == InputKeyOk ||
                  input_event->key == InputKeyUp ||
                  input_event->key == InputKeyLeft ||
                  input_event->key == InputKeyRight ||
                  input_event->key == InputKeyDown) {
            // All buttons (OK, Up, Left, Right, Down) can be used for input
            if(context->state == GameStateIdle) {
                // Only OK button starts the game from idle state
                if(input_event->key == InputKeyOk) {
                    // Start the game - generate a new pattern and show it
                    // We need 4 intervals for 5 vibrations
                    for(int i = 0; i < PATTERN_LENGTH - 1; i++) {
                        // Randomly select one of the three fixed pause durations
                        int random_choice = rand() % 3;
                        switch(random_choice) {
                            case 0:
                                context->pattern[i] = PAUSE_DURATION_1; // 200ms
                                break;
                            case 1:
                                context->pattern[i] = PAUSE_DURATION_2; // 500ms
                                break;
                            case 2:
                                context->pattern[i] = PAUSE_DURATION_3; // 800ms
                                break;
                        }
                    }
                    reset_pattern_state(context);
                    context->state = GameStateShowingPattern;
                    context->last_pattern_time = furi_get_tick(); // Record when pattern was shown
                    strcpy(context->status_text, "Watch the pattern.");
                }
            } else if(context->state == GameStateWaitingForInput) {
                // Player presses any button during input phase - store the time
                uint32_t current_time = furi_get_tick();

                if(context->current_input_index < PATTERN_LENGTH) {
                    // Store the time of this input
                    context->input_times[context->current_input_index] = current_time;
                    context->current_input_index++;
                    context->last_input_time = current_time;
                    context->timeout_replay_occurred = false; // Reset timeout replay flag on user input

                    if(context->current_input_index < PATTERN_LENGTH) {
                        // Still collecting inputs, don't evaluate yet
                    } else {
                        // Got all 5 inputs, now evaluate the rhythm
                        bool pattern_matched = true;

                        // Evaluate each interval between consecutive presses
                        for(int i = 0; i < PATTERN_LENGTH - 1; i++) {
                            // Calculate the actual time between this press and the next
                            uint32_t actual_interval = context->input_times[i + 1] - context->input_times[i];
                            uint32_t expected_interval = context->pattern[i];

                            // Calculate 40% tolerance
                            uint32_t tolerance = (expected_interval * 40) / 100; // 40% of the expected interval

                            // Check if actual interval is within tolerance of expected interval
                            if(actual_interval < expected_interval - tolerance ||
                               actual_interval > expected_interval + tolerance) {
                                pattern_matched = false;
                                break;
                            }
                        }

                        // Calculate accuracy based on how close the inputs were to the expected timing
                        float total_accuracy = 0.0f;
                        int valid_intervals = 0;

                        for(int i = 0; i < PATTERN_LENGTH - 1; i++) {
                            uint32_t actual_interval = context->input_times[i + 1] - context->input_times[i];
                            uint32_t expected_interval = context->pattern[i];

                            // Calculate percentage difference (0% = completely wrong, 100% = perfect)
                            if(expected_interval > 0) {
                                int32_t difference = abs((int32_t)(actual_interval - expected_interval));
                                // Use a more realistic accuracy calculation based on timing precision
                                // A perfect match is 100%, but small errors reduce accuracy significantly
                                float accuracy = fmaxf(0.0f, 100.0f - ((float)difference / (float)expected_interval) * 200.0f);
                                total_accuracy += accuracy;
                                valid_intervals++;
                            }
                        }

                        if(valid_intervals > 0) {
                            context->last_accuracy = total_accuracy / valid_intervals; // Average accuracy
                        } else {
                            context->last_accuracy = 0.0f;
                        }

                        if(pattern_matched) {
                            // Player completed the pattern correctly
                            context->total_correct++;
                            context->correct_in_a_row++;

                            // Update hi score if current streak is higher
                            if(context->correct_in_a_row > context->hi_score) {
                                context->hi_score = context->correct_in_a_row;
                            }

                            // Generate a new pattern for the next round (4 intervals for 5 vibrations)
                            // Seed the random number generator with current time for new pattern
                            srand(furi_get_tick());

                            for(int i = 0; i < PATTERN_LENGTH - 1; i++) {
                                // Randomly select one of the three fixed pause durations
                                int random_choice = rand() % 3;
                                switch(random_choice) {
                                    case 0:
                                        context->pattern[i] = PAUSE_DURATION_1; // 200ms
                                        break;
                                    case 1:
                                        context->pattern[i] = PAUSE_DURATION_2; // 500ms
                                        break;
                                    case 2:
                                        context->pattern[i] = PAUSE_DURATION_3; // 800ms
                                        break;
                                }
                            }

                            reset_pattern_state(context); // Reset for next pattern
                            context->state = GameStateShowingPattern;
                            context->last_pattern_time = furi_get_tick(); // Record when pattern was shown
                            strcpy(context->status_text, "Watch the pattern.");
                        } else {
                            // Incorrect timing - repeat the same pattern
                            context->correct_in_a_row = 0; // Reset in-a-row counter

                            reset_pattern_state(context); // Reset for the same pattern

                            // No background reset needed since we only have one background

                            // Play an error vibration pattern to indicate wrong input
                            furi_mutex_release(context->mutex);
                            // Create an error vibration pattern: multiple quick vibrations
                            for(int i = 0; i < 3; i++) {
                                notification_message(context->notification, &sequence_single_vibro);
                                furi_delay_ms(100); // Short pause between vibrations
                            }
                            furi_mutex_acquire(context->mutex, FuriWaitForever);

                            context->state = GameStateShowingPattern;
                            context->last_pattern_time = furi_get_tick(); // Record when pattern was shown
                            strcpy(context->status_text, "Watch again.");
                        }
                    }
                }
            }
        } else if(input_event->key == InputKeyBack) {
            // Exit the game by setting a special state that will be handled in the main loop
            context->state = GameStatePlaying; // Using this as an exit signal
        }
    }

    furi_mutex_release(context->mutex);
}

// Timer callback for game updates - called periodically to check for timeouts
static void vibration_game_update_timer_callback(void* ctx) {
    VibrationGameContext* context = (VibrationGameContext*)ctx;
    check_timeout_and_update(context);
}

// Function to play the vibration pattern
static void play_vibration_pattern(VibrationGameContext* context) {
    // Play the first vibration immediately
    notification_message(context->notification, &sequence_single_vibro);
    furi_delay_ms(VIBRATION_DURATION);

    // For the remaining 4 vibrations, wait for the pattern interval then vibrate
    for(int i = 0; i < PATTERN_LENGTH - 1; i++) {
        furi_delay_ms(context->pattern[i]);  // Wait for the timing interval
        // Play the next vibration
        notification_message(context->notification, &sequence_single_vibro);
        furi_delay_ms(VIBRATION_DURATION);
    }
}

// Helper function to reset pattern state variables
static void reset_pattern_state(VibrationGameContext* context) {
    context->current_input_index = 0;
    context->timeout_replay_occurred = false;
    context->pattern_reveal_index = 0;
    for(int i = 0; i < PATTERN_LENGTH; i++) {
        context->pattern_revealed[i] = false;
    }
}


// Function to check for timeout and update game state accordingly
static void check_timeout_and_update(VibrationGameContext* context) {
    furi_mutex_acquire(context->mutex, FuriWaitForever);

    if(context->state == GameStateWaitingForInput) {
        uint32_t current_time = furi_get_tick();
        // Check if 5 seconds have passed since the last input or pattern display
        uint32_t time_since_last_input = current_time - context->last_input_time;
        uint32_t time_since_last_pattern = current_time - context->last_pattern_time;

        // Use 5000 ms = 5 seconds (approximately 5000 ticks)
        // Only replay if timeout hasn't already occurred since last user input
        if(time_since_last_input > 5000 && time_since_last_pattern > 5000 && !context->timeout_replay_occurred) {
            // Reset the user's input progress immediately to clear the filled circles
            context->current_input_index = 0;
            view_port_update(context->view_port); // Force immediate UI update to clear the circles

            // Play the pattern directly without changing state to avoid double-play in main loop
            furi_mutex_release(context->mutex);
            furi_delay_ms(1000); // Wait 1 second before showing the pattern for a more relaxed experience
            play_vibration_pattern(context);
            furi_mutex_acquire(context->mutex, FuriWaitForever);

            // Update state after playing the pattern and record start time for input
            context->pattern_start_time = furi_get_tick(); // Start timing from when pattern finishes
            context->last_pattern_time = context->pattern_start_time; // Record when pattern was shown
            context->timeout_replay_occurred = true; // Mark that timeout replay has occurred
            context->state = GameStateWaitingForInput;
            context->last_input_time = context->pattern_start_time; // Reset timeout from now
            strcpy(context->status_text, "Repeat the pattern.");
        }
    }

    furi_mutex_release(context->mutex);
}

// Function to reset the game is not needed anymore as we handle it in the input callback
