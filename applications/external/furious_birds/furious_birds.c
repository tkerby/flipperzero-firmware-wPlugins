#include <gui/icon_i.h>
#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <furi_hal.h>
#include <stdlib.h>
#include <math.h>
#include <gui/view_dispatcher.h>
#include <gui/modules/widget.h>

#include "notifications.h"

/* generated by fbt from .png files in images folder */
#include <furious_birds_icons.h>

#define ANGLE_START 15

#define RED_START_X  9
#define RED_CENTER_X 7
#define RED_CENTER_Y 8

#define SLINGSHOT_X        24
#define SLINGSHOT_CENTER_X 4
#define SLINGSHOT_Y        35

#define RED_TO_SLINGSHOT_X (SLINGSHOT_X - RED_START_X)

#define ANGLE_MAX 45
#define ANGLE_MIN -45

#define AIMING_SPEED 2

#define PIG_CENTER_X      6
#define PIG_CENTER_Y      6
#define PIG_MIN_COUNT     3
#define PIG_MAX_COUNT     10
#define RED_SPEED         6
#define RED_INITIAL_SPEED 1.0
#define RED_GRAVITY       0.006

#define PIGS_AREA_X_START 50
#define PIGS_AREA_X_END   120
#define PIGS_AREA_Y_START 8
#define PIGS_AREA_Y_END   56

#define MIN_DISTANCE_BETWEEN_PIGS        14
#define MIN_DISTANCE_BETWEEN_RED_AND_PIG 13

#define AIMING_LINE_LENGTH 40

#define ATTTEMPT_COUNT 3

#define GAME_END_MESSAGE "No more attempts!"
#define SCORE_MESSAGE    "Your score: %ld"

#define SCREEN_WIDTH  128
#define SCREEN_HEIGHT 64

enum LogoState {
    LogoStateAnimating,
    LogoStateDisplay,
};

typedef struct {
    uint8_t state;
    uint8_t frame;
    uint8_t choise;
} LogoModel;

enum GameState {
    GameStateAiming,
    GameStateFlying,
    GameStateLoosing,
};

typedef struct {
    uint8_t x;
    uint8_t y;
    bool visible;
} Pig;

typedef struct {
    double x;
    double y;
    double vx;
    double vy;
} Red;

typedef struct {
    Red* red;
    Pig* pigs[PIG_MAX_COUNT];
    uint8_t pig_count;
    int8_t angle;
    double_t angle_radians;
    uint8_t state;
    double_t diff;
    int8_t diff_int;
    uint8_t red_speed;
    uint32_t level;
    uint8_t remaining_attempts;
    uint32_t score;
} AppModel;

typedef struct {
    bool sound;
} AppSettings;

typedef struct {
    Gui* gui;
    ViewDispatcher* view_dispatcher;
    View* logo_view;
    View* game_view;
    FuriThread* logo_thread;
    FuriTimer* logo_timer;
    FuriThread* worker_thread;
    FuriTimer* timer;
    AppModel* model;
    LogoModel* logo_model;
    NotificationApp* notification;
    AppSettings* settings;
    Widget* widget_about;
} App;

typedef enum {
    EventReserved = (1 << 0),
    EventStop = (1 << 1),
    EventTick = (1 << 2),
} EventFlags;

typedef enum {
    AppLogoView,
    AppAboutView,
    AppGameView,
} AppView;

#define EVENTS_MASK (EventStop | EventTick)

void draw_red(Canvas* canvas, AppModel* model) {
    int16_t draw_x = (int16_t)round(model->red->x) - RED_CENTER_X;
    int16_t draw_y = (int16_t)round(model->red->y) - RED_CENTER_Y;
    canvas_draw_icon(canvas, draw_x, draw_y, &I_Red);
}

void draw_slingshot(Canvas* canvas) {
    canvas_draw_icon(canvas, SLINGSHOT_X - SLINGSHOT_CENTER_X, SLINGSHOT_Y, &I_Slingshot);
}

uint8_t distance_between(Pig* pig1, Pig* pig2) {
    return sqrt(
        (pig2->x - pig1->x) * (pig2->x - pig1->x) + (pig2->y - pig1->y) * (pig2->y - pig1->y));
}

double distance_between_red_and_pig(Red* red, Pig* pig) {
    double dx = red->x - pig->x;
    double dy = red->y - pig->y;
    return sqrt(dx * dx + dy * dy);
}

double_t degree_to_radian(int8_t degree) {
    return ((double_t)degree) / 180 * ((double_t)M_PI);
}

double calculate_red_start_y(AppModel* model) {
    model->diff = tan(model->angle_radians);
    model->diff_int = RED_TO_SLINGSHOT_X * model->diff;
    return SLINGSHOT_Y + model->diff_int;
}

Red* init_red(AppModel* model) {
    Red* red = malloc(sizeof(Red));
    red->x = RED_START_X;
    red->y = calculate_red_start_y(model);
    red->vx = 0;
    red->vy = 0;
    return red;
}

Pig* create_random_pig(uint8_t i, Pig* pigs[]) {
    Pig* pig = malloc(sizeof(Pig));
    pig->visible = true;

    bool intercept = false;
    do {
        pig->x =
            (furi_hal_random_get() % (PIGS_AREA_X_END - PIGS_AREA_X_START)) + PIGS_AREA_X_START;
        pig->y =
            (furi_hal_random_get() % (PIGS_AREA_Y_END - PIGS_AREA_Y_START)) + PIGS_AREA_Y_START;

        intercept = false;
        for(uint8_t j = 0; j < i; j++) {
            if(distance_between(pigs[j], pig) < MIN_DISTANCE_BETWEEN_PIGS) {
                intercept = true;
                break;
            }
        }
    } while(intercept);

    return pig;
}

static uint32_t navigation_menu_callback(void* _context) {
    UNUSED(_context);
    return AppLogoView;
}

void reset_game(AppModel* model) {
    model->angle = ANGLE_START;
    model->angle_radians = degree_to_radian(model->angle);
    model->state = GameStateAiming;
    model->red = init_red(model);
    model->pig_count = PIG_MIN_COUNT;
    model->score = 0;
    model->level = 0;
    for(uint8_t i = 0; i < model->pig_count; i++) {
        model->pigs[i] = create_random_pig(i, model->pigs);
    }
    model->diff = tan(model->angle_radians);
    model->diff_int = RED_TO_SLINGSHOT_X * model->diff;
    model->remaining_attempts = ATTTEMPT_COUNT;
}

void draw_stats(Canvas* canvas, AppModel* model) {
    FuriString* xstr = furi_string_alloc();
    furi_string_printf(xstr, "score: %ld", model->score);
    canvas_draw_str(canvas, 0, 8, furi_string_get_cstr(xstr));
    furi_string_printf(xstr, "level: %ld", model->level);
    canvas_draw_str(canvas, 0, 16, furi_string_get_cstr(xstr));
    furi_string_printf(xstr, "attempts: %d", model->remaining_attempts);
    canvas_draw_str(canvas, 0, 24, furi_string_get_cstr(xstr));
    furi_string_free(xstr);
}

void draw_pigs(Canvas* canvas, AppModel* model) {
    for(uint8_t i = 0; i < model->pig_count; i++) {
        Pig* pig = model->pigs[i];
        if(pig->visible) {
            canvas_draw_icon(canvas, pig->x - PIG_CENTER_X, pig->y - PIG_CENTER_Y, &I_Pig);
        }
    }
}

void recalculate_start_position(AppModel* model) {
    model->angle_radians = degree_to_radian(model->angle);
    model->red->y = calculate_red_start_y(model);
    model->red->vx = 0;
    model->red->vy = 0;
}

void draw_aiming_line(Canvas* canvas, AppModel* model) {
    double x = SLINGSHOT_X;
    double y = SLINGSHOT_Y;
    double step_x = cos(model->angle_radians);
    double step_y = -sin(model->angle_radians);
    uint8_t finish_x = x + AIMING_LINE_LENGTH * step_x;
    while(x < finish_x) {
        canvas_draw_dot(canvas, round(x), round(y));
        x += 4 * step_x;
        y += 4 * step_y;
    }
}

void next_level(AppModel* model) {
    model->level++;
    model->state = GameStateAiming;
    model->red->x = RED_START_X;
    model->red->vx = 0;
    model->red->vy = 0;
    model->angle = ANGLE_START;
    model->angle_radians = degree_to_radian(model->angle);
    model->red->y = calculate_red_start_y(model);
    model->remaining_attempts = ATTTEMPT_COUNT;
    for(uint8_t i = 0; i < model->pig_count; i++) {
        free(model->pigs[i]);
    }
    if(model->pig_count < PIG_MAX_COUNT) {
        model->pig_count++;
    }
    for(uint8_t i = 0; i < model->pig_count; i++) {
        model->pigs[i] = create_random_pig(i, model->pigs);
    }
}

void next_attempt(AppModel* model) {
    model->state = GameStateAiming;
    model->red->x = RED_START_X;
    model->red->y = calculate_red_start_y(model);
    model->red->vx = 0;
    model->red->vy = 0;
    model->remaining_attempts--;
}

void draw_final_score(Canvas* canvas, AppModel* model) {
    canvas_set_font(canvas, FontPrimary);

    size_t s = snprintf(NULL, 0, SCORE_MESSAGE, model->score);
    char moves[s + 1];
    // Use snprintf to combine the score message and the actual score
    snprintf(moves, s + 1, SCORE_MESSAGE, model->score);

    int w = canvas_string_width(canvas, GAME_END_MESSAGE);
    int h = canvas_current_font_height(canvas) * 2;
    const int paddingV = 2;
    const int paddingH = 4;

    canvas_set_color(canvas, ColorWhite);
    canvas_draw_box(
        canvas,
        SCREEN_WIDTH / 2 - w / 2 - paddingH,
        SCREEN_HEIGHT / 2 - h / 2 - paddingV,
        w + paddingH * 2,
        h + paddingV * 2 + canvas_current_font_height(canvas));
    canvas_set_color(canvas, ColorBlack);
    canvas_draw_rframe(
        canvas,
        SCREEN_WIDTH / 2 - w / 2 - paddingH,
        SCREEN_HEIGHT / 2 - h / 2 - paddingV,
        w + paddingH * 2,
        h + paddingV * 2 + canvas_current_font_height(canvas),
        2);
    canvas_draw_str_aligned(
        canvas, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, AlignCenter, AlignCenter, GAME_END_MESSAGE);
    canvas_draw_str_aligned(
        canvas,
        SCREEN_WIDTH / 2,
        (SCREEN_HEIGHT / 2) + canvas_current_font_height(canvas),
        AlignCenter,
        AlignCenter,
        moves);
}

void draw_selection(Canvas* canvas, uint8_t choise) {
    UNUSED(choise);
    uint8_t shift_y = choise * 12;
    canvas_draw_line(canvas, 79, 32 + shift_y, 81, 32 + shift_y);
    canvas_draw_line(canvas, 79, 32 + shift_y, 79, 30 + shift_y);

    canvas_draw_line(canvas, 79, 20 + shift_y, 81, 20 + shift_y);
    canvas_draw_line(canvas, 79, 20 + shift_y, 79, 22 + shift_y);

    canvas_draw_line(canvas, 127, 32 + shift_y, 125, 32 + shift_y);
    canvas_draw_line(canvas, 127, 32 + shift_y, 127, 30 + shift_y);

    canvas_draw_line(canvas, 127, 20 + shift_y, 125, 20 + shift_y);
    canvas_draw_line(canvas, 127, 20 + shift_y, 127, 22 + shift_y);
}

static void logo_draw_callback(Canvas* canvas, void* _model) {
    LogoModel* model = _model;
    if(model->state == LogoStateAnimating) {
        switch(model->frame) {
        case 0:
            canvas_draw_icon(canvas, 0, 0, &I_Logo_0);
            break;
        case 1:
            canvas_draw_icon(canvas, 0, 0, &I_Logo_1);
            break;
        case 2:
            canvas_draw_icon(canvas, 0, 0, &I_Logo_2);
            break;
        default:
            break;
        }
    } else if(model->state == LogoStateDisplay) {
        canvas_draw_icon(canvas, 0, 0, &I_Logo_2);
        canvas_draw_str(canvas, 82, 30, "New game");
        canvas_draw_str(canvas, 91, 42, "About");
        canvas_draw_str(canvas, 94, 54, "Exit");
        draw_selection(canvas, model->choise);
    }
}

static void game_draw_callback(Canvas* canvas, void* _model) {
    AppModel* model = (AppModel*)_model;
    canvas_clear(canvas);
    canvas_set_bitmap_mode(canvas, true);
    canvas_set_color(canvas, ColorBlack);

    draw_slingshot(canvas);
    if(model->state == GameStateAiming) {
        draw_aiming_line(canvas, model);
    }
    draw_pigs(canvas, model);
    draw_stats(canvas, model);
    draw_red(canvas, model);
    if(model->state == GameStateLoosing) {
        draw_final_score(canvas, model);
    }
}
static bool logo_input_callback(InputEvent* event, void* ctx) {
    App* app = ctx;
    furi_assert(app);
    if(app->logo_model->state == LogoStateDisplay) {
        if(event->type == InputTypeShort) {
            if(event->key == InputKeyOk) {
                switch(app->logo_model->choise) {
                case 0:
                    reset_game(app->model);
                    view_dispatcher_switch_to_view(app->view_dispatcher, AppGameView);
                    break;
                case 1:
                    view_dispatcher_switch_to_view(app->view_dispatcher, AppAboutView);
                    break;
                case 2:
                    view_dispatcher_stop(app->view_dispatcher);
                    break;
                default:
                    break;
                }
            } else if(event->key == InputKeyBack) {
                view_dispatcher_stop(app->view_dispatcher);
            } else if(event->key == InputKeyUp && app->logo_model->choise > 0) {
                with_view_model(app->logo_view, LogoModel * model, { model->choise--; }, true);
            } else if(event->key == InputKeyDown && app->logo_model->choise < 2) {
                with_view_model(app->logo_view, LogoModel * model, { model->choise++; }, true);
            }
        }
    }

    return true;
}

static bool game_input_callback(InputEvent* event, void* ctx) {
    App* app = ctx;
    furi_assert(app);
    AppModel* model = app->model;

    if(model->state == GameStateAiming) {
        if(event->type == InputTypeShort || event->type == InputTypeRepeat) {
            if(event->key == InputKeyDown && model->angle > ANGLE_MIN) {
                model->angle -= AIMING_SPEED;
                recalculate_start_position(model);
            } else if(event->key == InputKeyUp && model->angle < ANGLE_MAX) {
                model->angle += AIMING_SPEED;
                recalculate_start_position(model);
            } else if(event->key == InputKeyOk) {
                notification_message(
                    app->notification, notification_red_start[app->settings->sound]);
                double speed = RED_INITIAL_SPEED;
                model->red->vx = cos(model->angle_radians) * speed;
                model->red->vy = -sin(model->angle_radians) * speed;
                model->state = GameStateFlying;
            } else if(event->key == InputKeyBack) {
                view_dispatcher_switch_to_view(app->view_dispatcher, AppLogoView);
            }
        }
    } else if(model->state == GameStateLoosing) {
        if(event->type == InputTypeShort && event->key == InputKeyBack) {
            reset_game(model);
            model->state = GameStateAiming;
        }
    }

    return true;
}

bool reached_border(Red* red) {
    return red->x > 152 || red->y < -5 || red->y > 71;
}

bool all_pigs_caught(AppModel* model) {
    for(uint8_t i = 0; i < model->pig_count; i++) {
        if(model->pigs[i]->visible) {
            return false;
        }
    }
    return true;
}

static int32_t furious_birds_logo(void* context) {
    furi_assert(context);
    App* app = context;

    while(app->logo_model->frame < 3) {
        uint32_t events = furi_thread_flags_wait(EventTick, FuriFlagWaitAny, FuriWaitForever);
        furi_check((events & FuriFlagError) == 0);
        if(events & EventTick) {
            with_view_model(
                app->logo_view,
                LogoModel * model,
                {
                    if(model->state == LogoStateAnimating) {
                        model->frame++;
                        notification_message(
                            app->notification, notification_logo[app->settings->sound]);
                    }
                    if(model->frame > 2) {
                        model->state = LogoStateDisplay;
                    }
                },
                true);
        }
    }
    return 0;
}

static int32_t furious_birds_worker(void* context) {
    furi_assert(context);
    App* app = context;
    UNUSED(app);

    while(1) {
        uint32_t events = furi_thread_flags_wait(EVENTS_MASK, FuriFlagWaitAny, FuriWaitForever);
        furi_check((events & FuriFlagError) == 0);

        if(events & EventStop) break;
        if(events & EventTick) {
            with_view_model(
                app->game_view,
                AppModel * model,
                {
                    if(model->state == GameStateFlying) {
                        double gravity = RED_GRAVITY;
                        model->red->x += model->red->vx;
                        model->red->y += model->red->vy;
                        model->red->vy += gravity;

                        for(uint8_t i = 0; i < model->pig_count; i++) {
                            if(!model->pigs[i]->visible) {
                                continue;
                            }

                            if(distance_between_red_and_pig(model->red, model->pigs[i]) <
                               MIN_DISTANCE_BETWEEN_RED_AND_PIG) {
                                model->score++;
                                model->pigs[i]->visible = false;
                                notification_message(
                                    app->notification,
                                    notification_pig_caught[app->settings->sound]);
                            }
                        }

                        if(reached_border(model->red)) {
                            if(all_pigs_caught(model)) {
                                next_level(model);
                                notification_message(
                                    app->notification,
                                    notification_next_level[app->settings->sound]);
                            } else {
                                next_attempt(model);
                                if(model->remaining_attempts == 0) {
                                    notification_message(
                                        app->notification,
                                        notification_lose_level[app->settings->sound]);
                                    model->state = GameStateLoosing;
                                    // reset_game(model);
                                }
                            }
                        }
                    }
                },
                true);
        }
    }

    return 0;
}

static void logo_timer_callback(void* context) {
    furi_assert(context);
    App* app = context;
    furi_thread_flags_set(furi_thread_get_id(app->logo_thread), EventTick);
}

static void furious_birds_timer_callback(void* context) {
    furi_assert(context);
    App* app = context;
    furi_thread_flags_set(furi_thread_get_id(app->worker_thread), EventTick);
}

App* app_alloc() {
    App* app = malloc(sizeof(App));

    // Gui
    app->gui = furi_record_open(RECORD_GUI);

    // View dispatcher
    app->view_dispatcher = view_dispatcher_alloc();
    view_dispatcher_enable_queue(app->view_dispatcher);
    view_dispatcher_attach_to_gui(app->view_dispatcher, app->gui, ViewDispatcherTypeFullscreen);

    // Views
    View* logo_view = view_alloc();
    app->logo_view = logo_view;
    view_set_context(logo_view, app);
    view_set_draw_callback(logo_view, logo_draw_callback);
    view_set_input_callback(logo_view, logo_input_callback);
    view_allocate_model(logo_view, ViewModelTypeLocking, sizeof(LogoModel));
    with_view_model(
        logo_view,
        LogoModel * model,
        {
            app->logo_model = model;
            model->state = LogoStateAnimating;
            model->frame = 0;
            model->choise = 0;
        },
        true);

    app->logo_thread = furi_thread_alloc_ex("FuriousBirdsLogo", 1024, furious_birds_logo, app);
    furi_thread_start(app->logo_thread);

    app->logo_timer = furi_timer_alloc(logo_timer_callback, FuriTimerTypePeriodic, app);
    furi_timer_start(app->logo_timer, furi_ms_to_ticks(700));

    // Main game view
    View* game_view = view_alloc();
    app->game_view = game_view;
    view_set_context(game_view, app);
    view_set_draw_callback(game_view, game_draw_callback);
    view_set_input_callback(game_view, game_input_callback);
    view_allocate_model(game_view, ViewModelTypeLocking, sizeof(AppModel));
    with_view_model(
        game_view,
        AppModel * model,
        {
            app->model = model;
            reset_game(model);
        },
        true);

    app->widget_about = widget_alloc();
    widget_add_text_scroll_element(
        app->widget_about,
        0,
        0,
        128,
        64,
        "Well-known birds and pigs game. Aim the bird on pigs and catch them all in three attempts\n\nauthor: @bmstr-ru\nhttps://github.com/bmstr-ru/furious-birds");
    view_set_previous_callback(widget_get_view(app->widget_about), navigation_menu_callback);
    view_dispatcher_add_view(
        app->view_dispatcher, AppAboutView, widget_get_view(app->widget_about));

    view_dispatcher_add_view(app->view_dispatcher, AppLogoView, app->logo_view);
    view_dispatcher_add_view(app->view_dispatcher, AppGameView, app->game_view);
    view_dispatcher_switch_to_view(app->view_dispatcher, AppLogoView);

    AppSettings* settings = malloc(sizeof(AppSettings));
    settings->sound = false;
    app->settings = settings;

    app->worker_thread =
        furi_thread_alloc_ex("FuriousBirdsWorker", 1024, furious_birds_worker, app);
    furi_thread_start(app->worker_thread);

    app->timer = furi_timer_alloc(furious_birds_timer_callback, FuriTimerTypePeriodic, app);
    furi_timer_start(app->timer, furi_ms_to_ticks(100 / RED_SPEED));

    app->notification = furi_record_open(RECORD_NOTIFICATION);

    notification_message(app->notification, notification_logo[app->settings->sound]);

    return app;
}

void app_free(App* app) {
    furi_assert(app);

    furi_timer_stop(app->timer);
    furi_timer_free(app->timer);

    furi_timer_stop(app->logo_timer);
    furi_timer_free(app->logo_timer);

    furi_thread_flags_set(furi_thread_get_id(app->worker_thread), EventStop);
    furi_thread_join(app->worker_thread);
    furi_thread_free(app->worker_thread);

    furi_thread_flags_set(furi_thread_get_id(app->logo_thread), EventStop);
    furi_thread_join(app->logo_thread);
    furi_thread_free(app->logo_thread);

    // Free animals
    free(app->model->red);
    for(uint8_t i = 0; i < app->model->pig_count; i++) {
        free(app->model->pigs[i]);
    }

    free(app->model);
    free(app->settings);

    // Free views
    view_dispatcher_remove_view(app->view_dispatcher, AppLogoView);
    view_free(app->logo_view);

    view_dispatcher_remove_view(app->view_dispatcher, AppGameView);
    view_free(app->game_view);

    view_dispatcher_remove_view(app->view_dispatcher, AppAboutView);
    widget_free(app->widget_about);

    view_dispatcher_free(app->view_dispatcher);

    // Close gui record
    furi_record_close(RECORD_GUI);
    app->gui = NULL;

    furi_record_close(RECORD_NOTIFICATION);
    app->notification = NULL;

    // Free rest
    free(app);
}

int32_t furious_birds_app(void* p) {
    UNUSED(p);
    App* app = app_alloc();
    view_dispatcher_run(app->view_dispatcher);
    app_free(app);
    return 0;
}
