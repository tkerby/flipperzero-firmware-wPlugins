#include <furi.h>

#include <gui/gui.h>
#include <gui/icon_i.h>

/* generated by fbt from .png files in images folder */
#include <space_invaders_icons.h>

#define DISPLAY_WIDTH  128
#define DISPLAY_HEIGHT 64

#define FPS 30

#define MAX_EXPLOSIONS     3
#define EXPLOSION_DURATION 15 // In frames

typedef enum {
    AppEventTypeDone,
} AppEventType;

typedef struct {
    AppEventType type;
} AppEvent;

typedef enum {
    GameStateStart,
    GameStatePlay,
    GameStatePause,
    GameStateWin,
    GameStateLost,
} GameState;

typedef struct {
    short int x;
    short int y;
    int time;
} Explosion;

typedef struct {
    // Curent state of the game
    GameState gameState;

    // Player coordinates
    short int playerX;
    // Direction of player movement
    short int playerDirection;

    //Playre score
    short int score;
    FuriString* score_string;

    // Projectile
    bool shoot;
    short int projectileX;
    short int projectileY;

    // Enemies
    short int enemyX[3][8];
    short int enemyY[3];
    short int enemyDirection;
    short int enemyCount[3];
    bool enemyAnimation;

    // Expolosions
    short int explosionCount;
    Explosion explosion[MAX_EXPLOSIONS];

    // Time of run (ms)
    int time;
} GameContext;

typedef struct {
    FuriMessageQueue* queue; // Event queue
    FuriTimer* timer; // Timer for redrawing the screen
    ViewPort* view_port; // Input and draw callbacks
    Gui* gui; // Fullscreen view

    Icon* playerIcon; // Player ship
    Icon* enemyIcon[2][3]; // Enemy ships
    Icon* boomIcon; // Explosion

    GameContext gameContext; // Application data
} AppContext;

void init_game_state(AppContext* app) {
    app->gameContext.gameState = GameStatePlay;

    app->gameContext.playerX = (DISPLAY_WIDTH - 13) / 2;
    app->gameContext.playerDirection = 0;
    app->gameContext.score = 0;
    app->gameContext.score_string = furi_string_alloc_set_str("0");
    app->gameContext.time = 0;
    app->gameContext.shoot = false;
    app->gameContext.enemyDirection = 1;
    app->gameContext.explosionCount = 0;
    app->gameContext.enemyAnimation = false;

    for(short int et = 0; et < 3; et++) {
        for(short int i = 0; i < 8; i++) {
            app->gameContext.enemyX[et][i] = i * 15;
            if(et == 0) app->gameContext.enemyX[et][i] += 2;
        }
        app->gameContext.enemyY[et] = et * 12;
        app->gameContext.enemyCount[et] = 8;
    }
}

static void my_draw_callback(Canvas* canvas, void* context) {
    furi_assert(context);
    AppContext* app = (AppContext*)context;

    canvas_set_bitmap_mode(canvas, true);

    for(short int i = 0; i < app->gameContext.explosionCount; i++) {
        canvas_draw_bitmap(
            canvas,
            app->gameContext.explosion[i].x,
            app->gameContext.explosion[i].y,
            11,
            9,
            icon_get_frame_data(app->boomIcon, 0));
    }

    if(app->gameContext.gameState == GameStateLost) {
        canvas_draw_bitmap(
            canvas, app->gameContext.playerX + 1, 56, 11, 8, icon_get_frame_data(app->boomIcon, 0));
    } else {
        canvas_draw_bitmap(
            canvas, app->gameContext.playerX, 56, 13, 8, icon_get_frame_data(app->playerIcon, 0));
    }

    canvas_set_color(canvas, ColorBlack);

    if(app->gameContext.shoot) {
        canvas_draw_line(
            canvas,
            app->gameContext.projectileX,
            app->gameContext.projectileY < 0 ? 0 : app->gameContext.projectileY,
            app->gameContext.projectileX,
            app->gameContext.projectileY + 3);
    }

    // If player won, exit here
    if(app->gameContext.gameState == GameStateWin) {
        canvas_set_font(canvas, FontPrimary);
        canvas_draw_str_aligned(canvas, 64, 31, AlignCenter, AlignBottom, "You win!");
        canvas_set_font(canvas, FontSecondary);
        canvas_draw_str_aligned(
            canvas,
            64,
            33,
            AlignCenter,
            AlignTop,
            furi_string_get_cstr(app->gameContext.score_string));
        return;
    }

    // Draw enemies
    for(short int et = 0; et < 3; et++) {
        for(short int i = 0; i < app->gameContext.enemyCount[et]; i++) {
            canvas_draw_bitmap(
                canvas,
                app->gameContext.enemyX[et][i],
                app->gameContext.enemyY[et],
                icon_get_width(app->enemyIcon[app->gameContext.enemyAnimation][et]),
                icon_get_height(app->enemyIcon[app->gameContext.enemyAnimation][et]),
                icon_get_frame_data(app->enemyIcon[app->gameContext.enemyAnimation][et], 0));
        }
    }

    // If player lost, show message
    if(app->gameContext.gameState == GameStateLost) {
        canvas_set_color(canvas, ColorBlack);
        canvas_draw_box(canvas, 39, 22, 50, 20);
        canvas_set_color(canvas, ColorWhite);
        canvas_set_font(canvas, FontPrimary);
        canvas_draw_str_aligned(canvas, 64, 31, AlignCenter, AlignBottom, "You lose!");
        canvas_set_font(canvas, FontSecondary);
        canvas_draw_str_aligned(
            canvas,
            64,
            33,
            AlignCenter,
            AlignTop,
            furi_string_get_cstr(app->gameContext.score_string));
        return;
    }

    // Game is paused
    if(app->gameContext.gameState == GameStatePause) {
        canvas_draw_box(canvas, 25, 22, 78, 20);
        canvas_set_color(canvas, ColorWhite);
        canvas_set_font(canvas, FontPrimary);
        canvas_draw_str_aligned(canvas, 64, 31, AlignCenter, AlignBottom, "Pause");
        canvas_set_font(canvas, FontSecondary);
        canvas_draw_str_aligned(canvas, 64, 33, AlignCenter, AlignTop, "Hold BACK to exit");
    }

    // App started
    if(app->gameContext.gameState == GameStateStart) {
        canvas_set_color(canvas, ColorBlack);
        canvas_draw_box(canvas, 25, 22, 78, 20);
        canvas_set_color(canvas, ColorWhite);
        canvas_set_font(canvas, FontPrimary);
        canvas_draw_str_aligned(canvas, 64, 31, AlignCenter, AlignBottom, "Space Invaders");
        canvas_set_font(canvas, FontSecondary);
        canvas_draw_str_aligned(canvas, 64, 33, AlignCenter, AlignTop, "Press OK to play");
        return;
    }

    // Draw score
    canvas_set_color(canvas, ColorXOR);
    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str_aligned(
        canvas,
        128,
        64,
        AlignRight,
        AlignBottom,
        furi_string_get_cstr(app->gameContext.score_string));
}

static void my_input_callback(InputEvent* input_event, void* context) {
    furi_assert(context);
    AppContext* app = (AppContext*)context;

    // Pause or exit on back button
    if(input_event->key == InputKeyBack) {
        if(input_event->type == InputTypeLong) {
            AppEvent event;
            event.type = AppEventTypeDone;
            furi_message_queue_put(app->queue, &event, FuriWaitForever);
        } else if(input_event->type == InputTypeShort) {
            if(app->gameContext.gameState == GameStatePlay) {
                app->gameContext.gameState = GameStatePause;
            } else if(app->gameContext.gameState == GameStatePause) {
                app->gameContext.gameState = GameStatePlay;
            }
        }
    }

    if(input_event->type == InputTypeShort && input_event->key == InputKeyOk) {
        // If player won, restart game on OK
        if(app->gameContext.gameState == GameStateWin ||
           app->gameContext.gameState == GameStateLost ||
           app->gameContext.gameState == GameStateStart) {
            init_game_state(app);
        }
        // Player shooting
        else if(!app->gameContext.shoot && app->gameContext.gameState == GameStatePlay) {
            app->gameContext.projectileX = app->gameContext.playerX + 6;
            app->gameContext.projectileY = DISPLAY_HEIGHT - 8;
            app->gameContext.shoot = true;
        }
    }

    // Player movement
    if(input_event->type == InputTypePress && (app->gameContext.gameState == GameStatePlay ||
                                               app->gameContext.gameState == GameStateWin)) {
        if(input_event->key == InputKeyLeft)
            app->gameContext.playerDirection = -1;
        else if(input_event->key == InputKeyRight)
            app->gameContext.playerDirection = 1;
    } else if(input_event->type == InputTypeRelease) {
        if(input_event->key == InputKeyLeft || input_event->key == InputKeyRight) {
            app->gameContext.playerDirection = 0;
        }
    }
}

static void timer_callback(void* context) {
    furi_assert(context);
    AppContext* app = (AppContext*)context;

    // Do nothing if game is paused
    if(app->gameContext.gameState == GameStatePause ||
       app->gameContext.gameState == GameStateStart) {
        return;
    }

    // Increase time
    app->gameContext.time += 1;

    // Explosion duration
    if(app->gameContext.explosionCount < MAX_EXPLOSIONS) {
        for(short int i = app->gameContext.explosionCount - 1; i >= 0; i--) {
            if(app->gameContext.time - app->gameContext.explosion[i].time > EXPLOSION_DURATION) {
                app->gameContext.explosionCount--;
                for(short int j = i; j < app->gameContext.explosionCount; j++) {
                    app->gameContext.explosion[j] = app->gameContext.explosion[j + 1];
                }
            }
        }
    }

    if(app->gameContext.time % 15 == 1) {
        app->gameContext.enemyAnimation = !app->gameContext.enemyAnimation;
    }

    // If lost, exit here
    if(app->gameContext.gameState == GameStateLost) {
        return;
    }

    // Player movement
    app->gameContext.playerX = app->gameContext.playerX + app->gameContext.playerDirection;
    if(app->gameContext.playerX > DISPLAY_WIDTH - 13)
        app->gameContext.playerX = DISPLAY_WIDTH - 13;
    if(app->gameContext.playerX < 0) app->gameContext.playerX = 0;

    // Projectile movement
    if(app->gameContext.shoot) {
        app->gameContext.projectileY--;
        if(app->gameContext.projectileY < -3) {
            app->gameContext.shoot = false;
        }
    }

    // Enemy movement
    if(app->gameContext.time % 3 == 0 && app->gameContext.gameState == GameStatePlay) {
        int enemyDirection = app->gameContext.enemyDirection;
        int maxEnemyX = 0;
        int minEnemyX = DISPLAY_WIDTH;
        bool movementY = false;

        // Find enemy bounderies
        for(short int et = 0; et < 3; et++) {
            if(app->gameContext.enemyCount[et] > 0) {
                int newMaxX = app->gameContext.enemyX[et][app->gameContext.enemyCount[et] - 1] +
                              icon_get_width(app->enemyIcon[app->gameContext.enemyAnimation][et]);
                if(maxEnemyX < newMaxX) maxEnemyX = newMaxX;
                if(minEnemyX > app->gameContext.enemyX[et][0])
                    minEnemyX = app->gameContext.enemyX[et][0];
            }
        }

        // Change direction and ascend
        if(enemyDirection == 1 && maxEnemyX >= DISPLAY_WIDTH) {
            app->gameContext.enemyDirection = -1;
            movementY = true;
        } else if(enemyDirection == -1 && minEnemyX <= 0) {
            app->gameContext.enemyDirection = 1;
            movementY = true;
        }
        // Or move in the direction
        else {
            for(short int et = 0; et < 3; et++) {
                for(short int i = 0; i < app->gameContext.enemyCount[et]; i++) {
                    app->gameContext.enemyX[et][i] += app->gameContext.enemyDirection;
                }
            }
        }

        for(short int et = 0; et < 3; et++) {
            if(movementY) {
                app->gameContext.enemyY[et]++;
                // If enemy touches ground, game over
                if(app->gameContext.enemyY[et] > 55 && app->gameContext.enemyCount[et] > 0) {
                    app->gameContext.gameState = GameStateLost;
                }
            }
            // If enemy touches player, game over
            else if(app->gameContext.enemyY[et] > 50) {
                for(short int i = 0; i < app->gameContext.enemyCount[et]; i++) {
                    int playerX1 = app->gameContext.playerX;
                    int playerX2 = app->gameContext.playerX + 13;
                    if(app->gameContext.enemyX[et][i] >=
                           playerX1 - icon_get_width(
                                          app->enemyIcon[app->gameContext.enemyAnimation][et]) &&
                       app->gameContext.enemyX[et][i] <= playerX2) {
                        app->gameContext.gameState = GameStateLost;
                    }
                }
            }
        }
    }

    // If lost, exit here
    if(app->gameContext.gameState == GameStateLost) {
        return;
    }

    // Test hit
    if(app->gameContext.shoot) {
        for(short int et = 0; et < 3; et++) {
            if(app->gameContext.projectileY < app->gameContext.enemyY[et] + 8 &&
               app->gameContext.projectileY > app->gameContext.enemyY[et] - 3) {
                for(short int j = 0; j < app->gameContext.enemyCount[et]; j++) {
                    if(app->gameContext.projectileX > app->gameContext.enemyX[et][j] &&
                       app->gameContext.projectileX <
                           app->gameContext.enemyX[et][j] +
                               icon_get_width(
                                   app->enemyIcon[app->gameContext.enemyAnimation][et])) {
                        Explosion explosion;
                        explosion.x = app->gameContext.enemyX[et][j];
                        explosion.y = app->gameContext.enemyY[et];
                        explosion.time = app->gameContext.time;
                        app->gameContext.explosion[app->gameContext.explosionCount] = explosion;
                        app->gameContext.explosionCount++;
                        for(short int k = j; k <= app->gameContext.enemyCount[et] - 1; k++) {
                            app->gameContext.enemyX[et][k] = app->gameContext.enemyX[et][k + 1];
                        }
                        app->gameContext.enemyCount[et]--;
                        app->gameContext.shoot = false;
                        app->gameContext.score += et == 0 ? 50 : et == 1 ? 20 : 10;
                        furi_string_printf(
                            app->gameContext.score_string, "%i", app->gameContext.score);
                        break;
                    }
                }
            }
            if(!app->gameContext.shoot) break;
        }
        if(app->gameContext.enemyCount[0] == 0 && app->gameContext.enemyCount[1] == 0 &&
           app->gameContext.enemyCount[2] == 0) {
            // Win
            app->gameContext.gameState = GameStateWin;
            return;
        }
    }
}

int32_t mytestapp_app(void* p) {
    UNUSED(p);

    // ---------------
    //      Init
    // ---------------
    AppContext* app = (AppContext*)malloc(sizeof(AppContext));

    // Create event queue
    app->queue = furi_message_queue_alloc(8, sizeof(AppEvent));

    // Create view port
    app->view_port = view_port_alloc();
    view_port_draw_callback_set(app->view_port, my_draw_callback, app);
    view_port_input_callback_set(app->view_port, my_input_callback, app);
    view_port_set_orientation(app->view_port, ViewPortOrientationHorizontal);

    // Create gui
    app->gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(app->gui, app->view_port, GuiLayerFullscreen);

    // Create timer
    app->timer = furi_timer_alloc(timer_callback, FuriTimerTypePeriodic, app);
    furi_timer_start(app->timer, 1000 / FPS);

    app->gameContext.score_string = furi_string_alloc();

    // ---------------
    //      Setup
    // ---------------

    app->playerIcon = (Icon*)&I_player;
    app->enemyIcon[0][0] = (Icon*)&I_enemy1a;
    app->enemyIcon[0][1] = (Icon*)&I_enemy2a;
    app->enemyIcon[0][2] = (Icon*)&I_enemy3a;
    app->enemyIcon[1][0] = (Icon*)&I_enemy1b;
    app->enemyIcon[1][1] = (Icon*)&I_enemy2b;
    app->enemyIcon[1][2] = (Icon*)&I_enemy3b;
    app->boomIcon = (Icon*)&I_boom;

    init_game_state(app);
    app->gameContext.gameState = GameStateStart;

    // ---------------
    //    Main loop
    // ---------------
    AppEvent event;
    while(true) {
        if(furi_message_queue_get(app->queue, &event, FuriWaitForever) == FuriStatusOk) {
            if(event.type == AppEventTypeDone) {
                break;
            }
        } else {
            break;
        }
    }

    // ---------------
    //     Cleanup
    // ---------------

    // Free resources
    furi_string_free(app->gameContext.score_string);
    furi_timer_free(app->timer);
    furi_message_queue_free(app->queue);
    view_port_enabled_set(app->view_port, false);
    gui_remove_view_port(app->gui, app->view_port);
    view_port_free(app->view_port);
    furi_record_close(RECORD_GUI);
    free(app);

    return 0;
}
