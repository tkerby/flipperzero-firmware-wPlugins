/*
My first flipper application
Simple strobometer which can be used to measure the speed of a rotating object.

Parts of the code are taken from
https://github.com/instantiator/flipper-zero-tutorial-app/
https://github.com/flipperdevices/flipperzero-firmware/blob/dev/applications/examples/example_thermo/example_thermo.c
https://github.com/flipperdevices/flipperzero-firmware/blob/7291e6bd46c564400cdd3e9e7434f2c6e3a5ff28/targets/f7/furi_hal/furi_hal_pwm.c
*/

#include <furi.h>

#include <furi_hal_power.h>
#include <furi_hal_pwm.h>
#include <furi_hal_bus.h>

#include <stm32wbxx_ll_lptim.h>
#include <stm32wbxx_ll_rcc.h>

#include <gui/gui.h>
#include <gui/view_port.h>
#include <gui/elements.h>

#include <math.h>

#define TAG "strobometer"

/* generated by fbt from .png files in images folder */
#include <strobometer_icons.h>

#define STROBOSCOPE_PIN (FuriHalPwmOutputIdLptim2PA4)

/** the app context struct */
typedef struct {
    Gui* gui;
    ViewPort* view_port;
    FuriMessageQueue* event_queue;
    int frequency; // frequency of the strobometer
    unsigned short num_digits;
    unsigned short selected; // selected place in the frequency (0-(num_digits-1))
    int max_frequency; // pow(10,num_digits)-1
    bool output; // output state of the strobometer
} StrobometerAppContext;

/* Draw the GUI of the application. The screen is completely redrawn during each call. */

static void input_box(Canvas* canvas, int x, int y, const char* value, bool selected) {
    canvas_set_font(canvas, FontBigNumbers);
    canvas_draw_str_aligned(canvas, x, y, AlignLeft, AlignTop, value);
    if(selected) {
        canvas_draw_rframe(canvas, x - 3, y - 3, 16, 20, 3);
        canvas_draw_icon(canvas, x + 2, y - 8, &I_ButtonUp_7x4);
        canvas_draw_icon(canvas, x + 2, y + 18, &I_ButtonDown_7x4);
    }
}

static void strobometer_app_draw_callback(Canvas* canvas, void* ctx) {
    StrobometerAppContext* context = ctx;
    char text_store[32];

    // canvas_set_font(canvas, FontPrimary);
    // canvas_draw_str_aligned(canvas, middle_x, 12, AlignCenter, AlignBottom, "Strobometer");
    // canvas_draw_line(canvas, 0, 16, 128, 16);

    // Draw Output Pin Info
    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str(canvas, 10 + 6, 7, "A4");
    canvas_draw_icon(canvas, 10, 0, &I_SmallArrowUp_3x5);

    canvas_draw_str(canvas, 49 + 6, 7, "GND");
    canvas_draw_icon(canvas, 49, 0, &I_SmallArrowUp_3x5);

    // Draw RPM Input View
    for(int i = 0; i < context->num_digits; i++) {
        snprintf(text_store, sizeof(text_store), "%i", context->frequency / (int)pow(10, i) % 10);
        input_box(
            canvas,
            85 - 16 * i,
            canvas_height(canvas) / 2U - 7,
            text_store,
            i == context->selected);
    }
    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str_aligned(
        canvas, 101, canvas_height(canvas) / 2U, AlignLeft, AlignCenter, "RPM");

    // Draw Output Button
    if(context->output) {
        elements_button_center(canvas, "Stop");
    } else {
        elements_button_center(canvas, "Run");
    }
}

static void strobometer_app_input_callback(InputEvent* event, void* ctx) {
    StrobometerAppContext* context = ctx;
    furi_message_queue_put(context->event_queue, event, FuriWaitForever);
}

// Define custom PWM functions for PA4 that allow fractional frequencies
void hal_pwm_start(uint32_t freq_rpm, uint8_t duty_cycle);
void hal_pwm_set_params(uint32_t freq_rpm, uint8_t duty_cycle);
void hal_pwm_stop();
bool hal_pwm_is_running();

int duty_cycle_function(int frequency) {
    return (int)ceil(0.4342944819f * logf(frequency) - 1);
}

int changeFrequency(int frequency, int amount, int min, int max) {
    int result = frequency + amount;
    if(result < min) {
        result = max;
    } else if(result > max) {
        result = min;
    }
    return result;
}

static void strobometer_app_run(StrobometerAppContext* context) {
    furi_hal_power_enable_otg();

    view_port_enabled_set(context->view_port, true);

    bool frequency_changed = false;

    for(bool is_running = true; is_running;) {
        InputEvent event;

        const FuriStatus status =
            furi_message_queue_get(context->event_queue, &event, FuriWaitForever);
        if(status != FuriStatusOk) {
            continue;
        }

        if(event.type != InputTypeRepeat && event.type != InputTypePress) {
            continue;
        }

        // Change the selected digit and frequency
        if(event.key == InputKeyLeft) {
            context->selected = (context->selected + 1) % context->num_digits;
        } else if(event.key == InputKeyRight) {
            context->selected =
                (context->selected + (context->num_digits - 1)) % context->num_digits;
        }
        if(event.key == InputKeyUp) {
            context->frequency = changeFrequency(
                context->frequency, (int)pow(10, context->selected), 1, context->max_frequency);
            frequency_changed = true;
        } else if(event.key == InputKeyDown) {
            context->frequency = changeFrequency(
                context->frequency,
                -1 * (int)pow(10, context->selected),
                1,
                context->max_frequency);
            ;
            frequency_changed = true;
        }

        if(frequency_changed) {
            hal_pwm_set_params(context->frequency, duty_cycle_function(context->frequency));
            frequency_changed = false;
        }

        if(event.type != InputTypePress) {
            continue;
        }

        // Exit the app or start/stop the output
        if(event.key == InputKeyBack) {
            is_running = false;
        }
        if(event.key == InputKeyOk) {
            if(context->output) {
                if(hal_pwm_is_running()) {
                    hal_pwm_stop();
                }
                context->output = 0;
            } else {
                hal_pwm_start(context->frequency, duty_cycle_function(context->frequency));
                context->output = 1;
            }
        }

        view_port_update(context->view_port);
    }

    if(hal_pwm_is_running()) {
        hal_pwm_stop();
    }

    furi_hal_power_disable_otg();
}

static StrobometerAppContext* strobometer_app_context_alloc(void) {
    StrobometerAppContext* context = malloc(sizeof(StrobometerAppContext));

    context->view_port = view_port_alloc();
    view_port_draw_callback_set(context->view_port, strobometer_app_draw_callback, context);
    view_port_input_callback_set(context->view_port, strobometer_app_input_callback, context);

    context->event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    context->gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(context->gui, context->view_port, GuiLayerFullscreen);

    context->num_digits = 6;
    context->frequency = 1;
    context->selected = 0;
    context->max_frequency = (int)pow(10, context->num_digits) - 1;
    context->output = false;

    return context;
}

static void strobometer_app_context_free(StrobometerAppContext* context) {
    view_port_enabled_set(context->view_port, false);
    gui_remove_view_port(context->gui, context->view_port);

    furi_message_queue_free(context->event_queue);
    view_port_free(context->view_port);

    furi_record_close(RECORD_GUI);
}

void strobometer_app_set_log_level() {
#ifdef FURI_DEBUG
    furi_log_set_level(FuriLogLevelTrace);
#else
    furi_log_set_level(FuriLogLevelInfo);
#endif
}

int32_t strobometer_app(void* p) {
    UNUSED(p);
    strobometer_app_set_log_level();

    FURI_LOG_I(TAG, "Strobometer app starting...");

    StrobometerAppContext* context = strobometer_app_context_alloc();

    strobometer_app_run(context);

    strobometer_app_context_free(context);

    return 0;
}

// Custom PWM functions

const uint32_t lptim_psc_table[] = {
    LL_LPTIM_PRESCALER_DIV1,
    LL_LPTIM_PRESCALER_DIV2,
    LL_LPTIM_PRESCALER_DIV4,
    LL_LPTIM_PRESCALER_DIV8,
    LL_LPTIM_PRESCALER_DIV16,
    LL_LPTIM_PRESCALER_DIV32,
    LL_LPTIM_PRESCALER_DIV64,
    LL_LPTIM_PRESCALER_DIV128,
};

void hal_pwm_start(uint32_t freq_rpm, uint8_t duty_cycle) {
    furi_hal_gpio_init_ex(
        &gpio_ext_pa4,
        GpioModeAltFunctionPushPull,
        GpioPullNo,
        GpioSpeedVeryHigh,
        GpioAltFn14LPTIM2);

    furi_hal_bus_enable(FuriHalBusLPTIM2);

    LL_LPTIM_SetUpdateMode(LPTIM2, LL_LPTIM_UPDATE_MODE_ENDOFPERIOD);
    LL_RCC_SetLPTIMClockSource(LL_RCC_LPTIM2_CLKSOURCE_PCLK1);
    LL_LPTIM_SetClockSource(LPTIM2, LL_LPTIM_CLK_SOURCE_INTERNAL);
    LL_LPTIM_ConfigOutput(LPTIM2, LL_LPTIM_OUTPUT_WAVEFORM_PWM, LL_LPTIM_OUTPUT_POLARITY_INVERSE);
    LL_LPTIM_SetCounterMode(LPTIM2, LL_LPTIM_COUNTER_MODE_INTERNAL);

    LL_LPTIM_Enable(LPTIM2);

    hal_pwm_set_params(freq_rpm, duty_cycle);

    LL_LPTIM_StartCounter(LPTIM2, LL_LPTIM_OPERATING_MODE_CONTINUOUS);
}

void hal_pwm_set_params(uint32_t freq_rpm, uint8_t duty_cycle) {
    furi_assert(freq_rpm > 0);
    float freq_Hz = freq_rpm / 60.0f; // Convert RPM to Hz
    float freq_div = 32768LU / freq_Hz; // Use LSE clock frequency
    uint32_t prescaler = 0;
    float period = 0;

    do {
        period = freq_div / (1UL << prescaler);
        if(period <= 0xFFFF) {
            break;
        }
        prescaler++;
        if(prescaler > 7) {
            furi_assert(0 && "Frequency out of range for LSE clock");
        }
    } while(1);

    uint32_t compare = (uint32_t)(period * duty_cycle / 100.0f);

    LL_LPTIM_SetPrescaler(LPTIM2, lptim_psc_table[prescaler]);
    LL_LPTIM_SetAutoReload(LPTIM2, (uint32_t)period);
    LL_LPTIM_SetCompare(LPTIM2, compare);

    LL_RCC_SetLPTIMClockSource(LL_RCC_LPTIM2_CLKSOURCE_LSE);
}

void hal_pwm_stop() {
    furi_hal_gpio_init_simple(&gpio_ext_pa4, GpioModeAnalog);
    furi_hal_bus_disable(FuriHalBusLPTIM2);
}

bool hal_pwm_is_running() {
    return furi_hal_bus_is_enabled(FuriHalBusLPTIM2);
}
