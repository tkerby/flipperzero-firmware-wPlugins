#include <furi.h>
#define TAG "delfyRTL"
#include <gui/gui.h>
#include <expansion/expansion.h>
#include <furi_hal.h>
#include "uart_helper.h"
#include <gui/view_dispatcher.h>
#include <gui/scene_manager.h>
#include <gui/modules/menu.h>
#include <gui/modules/submenu.h>
#include <gui/modules/text_input.h>
#include <gui/modules/loading.h>
#include <gui/modules/widget.h>
#include <gui/modules/variable_item_list.h>
#include <gui/modules/byte_input.h>
#include <furi_hal_random.h>

/* generated by fbt from .png files in images folder */
#include <delfyrtl_icons.h>
#define DEVICE_BAUDRATE        115200
#define LINE_DELIMITER         '\n'
#define INCLUDE_LINE_DELIMITER false
#define MAC_LENGH              6

#define WEP_ENABLED    0x0001
#define TKIP_ENABLED   0x0002
#define AES_ENABLED    0x0004
#define SHARED_ENABLED 0x00008000
#define WPA_SECURITY   0x00200000
#define WPA2_SECURITY  0x00400000
#define WPA3_SECURITY  0x00800000

//Pantallas APP
typedef enum {
    mainMenuScene,
    scanNetworksScene,
    listNetworksScene,
    wifiInfoScene,
    configAttackScene,
    evilCredsScene,
    aPmacAddresScene,
    beaconNetworkScene,
    customBeaconScene,
    beaconInfoScene,
    helpScene,

    DelfyRTLSceneCount
} delfyRTLScene;

//Vistas APP
typedef enum {
    mainMenuView,
    loadingView,
    scannedWifisView,
    wifiInfoView,
    configAttackView,
    evilCredsView,
    aPmacAddresView,
    beaconListView,
    beaconInfoView,
    bssidTextInputView,
    helpView

} delfyRTLView;

const char* const captive_portals[4] = {
    "Default",
    "Facebook",
    "Amazon",
    "Apple",
};

const char* const deauth_reasons[25] = {
    "Reserved.",
    "Unspecified reason.",
    "Previous authentication no longer valid.",
    "Deauthenticated because sending station (STA) is leaving or has left Independent Basic Service Set (IBSS) or ESS.",
    "Disassociated due to inactivity.",
    "Disassociated because WAP device is unable to handle all currently associated STAs.",
    "Class 2 frame received from nonauthenticated STA.",
    "Class 3 frame received from nonassociated STA.",
    "Disassociated because sending STA is leaving or has left Basic Service Set (BSS).",
    "STA requesting (re)association is not authenticated with responding STA.",
    "Disassociated because the information in the Power Capability element is unacceptable.",
    "Disassociated because the information in the Supported Channels element is unacceptable.",
    "Disassociated due to BSS Transition Management.",
    "Invalid element, that is, an element defined in this standard for which the content does not meet the specifications in Clause 8.",
    "Message integrity code (MIC) failure.",
    "4-Way Handshake timeout.",
    "Group Key Handshake timeout.",
    "Element in 4-Way Handshake different from (Re)Association Request/ Probe Response/Beacon frame.",
    "Invalid group cipher.",
    "Invalid pairwise cipher.",
    "Invalid AKMP.",
    "Unsupported RSNE version.",
    "Invalid RSNE capabilities.",
    "IEEE 802.1X authentication failed.",
    "Cipher suite rejected because of the security policy.",
};
static const Icon* rick[] = {&I_rick0,  &I_rick1,  &I_rick2,  &I_rick3,  &I_rick4,  &I_rick5,
                             &I_rick6,  &I_rick7,  &I_rick8,  &I_rick9,  &I_rick10, &I_rick11,
                             &I_rick12, &I_rick13, &I_rick14, &I_rick15, &I_rick16, &I_rick17,
                             &I_rick18, &I_rick19, &I_rick20, &I_rick21, &I_rick22, &I_rick23};
const char* const mac_type[4] = {
    "Default",
    "Same as AP",
    "Random",
    "Custom",
};

typedef struct {
    int idAP;
    char* APssid;
    char APbssid[18];
    int chanel;
    int rssi;
    int security;
    bool deauth;
} APDetails;

char credentials[1000];
//Objeto del APP

typedef struct delfyRTL {
    SceneManager* scene_manager;
    ViewDispatcher* view_dispatcher;
    Loading* loading;
    Menu* menu;
    VariableItemList* variableList;
    Submenu* submenu;
    ByteInput* byteInput;
    int submenuIndex;
    int menuIndex;
    TextInput* text_input;
    Widget* widget;
    char* ssidAP;
    uint8_t ssidAPLength;
    UartHelper* uart_helper;
    APDetails* wifiList;
    int selectedWifi;
    int wifiCount;
    int captivePortal;
    int deauthReason;
    int mac_type;
    char customMac[18];
    uint8_t byte_input_store[MAC_LENGH];
    FuriTimer* timer;
    int rickIndex;
} delfyRTL;

//Las opciones del menu
typedef enum {
    ScanWifi = 0,
    ListWifis = 1,
    CustomBeacon = 2,
    Help = 3,
    Exit = 4,
} MainMenuIndex;

typedef enum {
    SsidAPInputSceneSaveEvent,
} CustoAPInputEvent;

bool scanFinish = false;
static void listed_wifis_item_callback(void* context, uint32_t index);
void delfyRTL_menu_callback(void* context, uint32_t index) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    FURI_LOG_I("delfyRTL", "index: %ld", index);
    switch(index) {
    case ScanWifi:
        FURI_LOG_I("delfyRTL", "scanWifis");
        scene_manager_handle_custom_event(app->scene_manager, ScanWifi);
        break;
    case ListWifis:
        FURI_LOG_I("delfyRTL", "listwifis");
        scene_manager_handle_custom_event(app->scene_manager, ListWifis);
        break;
    case CustomBeacon:
        FURI_LOG_I("delfyRTL", "customAP");
        scene_manager_handle_custom_event(app->scene_manager, CustomBeacon);
        break;
    case Help:
        FURI_LOG_I("delfyRTL", "Help");
        scene_manager_handle_custom_event(app->scene_manager, Help);
        break;
    case Exit:
        FURI_LOG_I("delfyRTL", "Exit");
        view_dispatcher_stop(app->view_dispatcher);
        //scene_manager_handle_custom_event(app->scene_manager, Exit);
        break;
    default:
        break;
    }
}

//Todos los eventos de la APP
void main_menu_scene_on_enter(void* context) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    menu_reset(app->menu);
    menu_add_item(app->menu, "Scan Wifi", &I_Scan_Wifi, ScanWifi, delfyRTL_menu_callback, app);
    menu_add_item(app->menu, "List Wifis", &I_List_Wifi, ListWifis, delfyRTL_menu_callback, app);
    menu_add_item(
        app->menu, "Send Beacon", &I_random_AP, CustomBeacon, delfyRTL_menu_callback, app);
    menu_add_item(app->menu, "Help", &I_help, Help, delfyRTL_menu_callback, app);
    menu_add_item(app->menu, "Exit", &I_exit, Exit, delfyRTL_menu_callback, app);
    menu_set_selected_item(app->menu, app->menuIndex);
    view_dispatcher_switch_to_view(app->view_dispatcher, mainMenuView);

    UNUSED(context);
}
static void app_free(delfyRTL* app);
bool main_menu_scene_on_event(void* context, SceneManagerEvent event) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;

    FURI_LOG_I("delfyRTL", "%s event.type: %d", __func__, event.type);
    FURI_LOG_I("delfyRTL", "%s event.event: %ldd", __func__, event.event);
    switch(event.type) {
    case SceneManagerEventTypeCustom:
        switch(event.event) {
        case ScanWifi:
            scene_manager_next_scene(app->scene_manager, scanNetworksScene);
            break;
        case ListWifis:
            scene_manager_next_scene(app->scene_manager, listNetworksScene);
            break;
        case CustomBeacon:
            scene_manager_next_scene(app->scene_manager, beaconNetworkScene);
            break;
        case Help:
            scene_manager_next_scene(app->scene_manager, helpScene);
            break;
        default:
            FURI_LOG_W("delfyRTL", "Evento desconocido: %ld", event.event);
            break;
        }
        return true;
        break;
    case SceneManagerEventTypeBack:

        break;
    default:
        FURI_LOG_W("delfyRTL", "Tipo de evento desconocido: %d", event.type);

        break;
    }
    return false;
}

void main_menu_scene_on_exit(void* context) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(context);
}
void scan_networks_scene_on_enter(void* context) {
    FURI_LOG_D(TAG, __func__);

    delfyRTL* app = context;
    app->menuIndex = 0;
    view_dispatcher_switch_to_view(app->view_dispatcher, loadingView);
    for(int i = 0; i < app->wifiCount; i++) {
        free(app->wifiList[i].APssid);
    }
    free(app->wifiList);

    app->wifiList = NULL;
    app->wifiCount = 0;

    uart_helper_send(app->uart_helper, "SCAN\n", 5);
    scanFinish = false;
    int times = 0;
    while(scanFinish == false && times < 20) {
        furi_delay_ms(500);
        times++;
    }

    submenu_reset(app->submenu);
    uart_helper_send(app->uart_helper, "LIST\n", 5);

    scene_manager_previous_scene(app->scene_manager);
}
bool scan_networks_scene_on_event(void* context, SceneManagerEvent event) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(context);
    switch(event.type) {
    case SceneManagerEventTypeCustom:
        return true;
    default:
        break;
    }
    return false;
}
void scan_networks_scene_on_exit(void* context) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(context);
}
void list_networks_scene_on_enter(void* context) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    app->menuIndex = 1;
    char* channelSt;
    app->submenuIndex = 0;
    submenu_reset(app->submenu);
    submenu_set_header(app->submenu, "Scanned wifis");
    for(int i = 0; i < app->wifiCount; i++) {
        char temp[230] = "";
        if(app->wifiList[i].deauth) {
            strcat(temp, "D|");
        }
        if(app->wifiList[i].chanel > 14) {
            channelSt = "5G";
        } else {
            channelSt = "2G";
        }
        strcat(temp, channelSt);
        strcat(temp, "|");
        strcat(temp, app->wifiList[i].APssid);
        submenu_add_item(app->submenu, temp, app->submenuIndex++, listed_wifis_item_callback, app);
    }
    submenu_set_selected_item(app->submenu, app->selectedWifi);

    view_dispatcher_switch_to_view(app->view_dispatcher, scannedWifisView);
}
bool list_networks_scene_on_event(void* context, SceneManagerEvent event) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(context);
    switch(event.type) {
    case SceneManagerEventTypeCustom:
        return true;
    default:
        break;
    }
    return false;
}
void list_networks_scene_on_exit(void* context) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(context);
}

static void listed_wifis_item_callback(void* context, uint32_t index) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;

    app->selectedWifi = index;

    scene_manager_next_scene(app->scene_manager, wifiInfoScene);
}

void beacon_networks_text_input_callback(void* context) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;

    scene_manager_handle_custom_event(app->scene_manager, SsidAPInputSceneSaveEvent);
}
static void listed_beacon_items_callback(void* context, uint32_t index) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    app->submenuIndex = index;
    switch(index) {
    case 0:
        //Custom
        scene_manager_next_scene(app->scene_manager, customBeaconScene);
        break;
    case 1:
        //Random
        uart_helper_send(app->uart_helper, "RANDOM\n", 7);
        scene_manager_next_scene(app->scene_manager, beaconInfoScene);
        break;
    case 2:
        //RickRoll
        uart_helper_send(app->uart_helper, "RICKROLL\n", 9);
        scene_manager_next_scene(app->scene_manager, beaconInfoScene);
        break;
    }
    UNUSED(context);

    UNUSED(index);
}
void beacon_network_scene_on_enter(void* context) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    app->menuIndex = 2;
    submenu_reset(app->submenu);
    submenu_set_header(app->submenu, "Select type of beacon");
    submenu_add_item(app->submenu, "Custom AP Beacon", 0, listed_beacon_items_callback, app);
    submenu_add_item(app->submenu, "Random AP Beacon", 1, listed_beacon_items_callback, app);
    submenu_add_item(app->submenu, "RickRoll AP Beacon", 2, listed_beacon_items_callback, app);

    view_dispatcher_switch_to_view(app->view_dispatcher, beaconListView);
}

bool beacon_network_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false;
}

void beacon_network_scene_on_exit(void* context) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(context);
}
void info_wifi_scene_on_enter(void* context);
void info_wifi_button_press(GuiButtonType result, InputType type, void* context) {
    FURI_LOG_D(TAG, __func__);
    FURI_LOG_D(TAG, "%d %d", type, result);
    delfyRTL* app = context;
    char cadena[13] = "";
    if(result == GuiButtonTypeCenter && type == 0) {
        if(app->wifiList[app->selectedWifi].deauth == false) {
            app->wifiList[app->selectedWifi].deauth = true;
            snprintf(cadena, 13, "DEAUTH %d\n", app->selectedWifi);
        } else {
            app->wifiList[app->selectedWifi].deauth = false;
            snprintf(cadena, 13, "STOP %d\n", app->selectedWifi);
        }
        info_wifi_scene_on_enter(app);
        uart_helper_send(app->uart_helper, cadena, strlen(cadena));
    } else if(result == GuiButtonTypeLeft && type == 0) {
        scene_manager_next_scene(app->scene_manager, configAttackScene);
    } else if(result == GuiButtonTypeRight && type == 0) {
        credentials[0] = '\0';
        snprintf(cadena, 13, "EVIL %d\n", app->selectedWifi);

        info_wifi_scene_on_enter(app);
        FURI_LOG_D(TAG, cadena);
        uart_helper_send(app->uart_helper, cadena, strlen(cadena));
        scene_manager_next_scene(app->scene_manager, evilCredsScene);
    }
}
void info_wifi_scene_on_enter(void* context) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    widget_reset(app->widget);
    char infoWifi[100] = "No wifi";
    if(app->selectedWifi >= 0 && app->selectedWifi < app->wifiCount) {
        char* security;
        switch(app->wifiList[app->selectedWifi].security) {
        case 0:
            security = "OPEN";
            break;
        case(WEP_ENABLED):
            security = "WEP_PSK";
            break;
        case(WEP_ENABLED | SHARED_ENABLED):
            security = "WEP_SHARED";
            break;
        case(WPA_SECURITY | TKIP_ENABLED):
            security = "WPA_TKIP_PSK";
            break;
        case(WPA_SECURITY | AES_ENABLED):
            security = "WPA_AES_PSK";
            break;
        case(WPA2_SECURITY | AES_ENABLED):
            security = "WPA2_AES_PSK";
            break;
        case(WPA2_SECURITY | TKIP_ENABLED):
            security = "WPA2_TKIP_PSK";
            break;
        case(WPA2_SECURITY | AES_ENABLED | TKIP_ENABLED):
            security = "WPA2_MIXED_TKIP";
            break;
        case(WPA_SECURITY | WPA2_SECURITY):
            security = "WPA_WPA2_MIXED";
            break;
        case(WPA_SECURITY | WPA2_SECURITY | TKIP_ENABLED):
            security = "WPA_WPA2_MIXED_TKIP";
            break;
        case(WPA_SECURITY | WPA2_SECURITY | AES_ENABLED):
            security = "WPA_WPA2_MIXED_AES";
            break;
        case(WPA_SECURITY | WPA2_SECURITY | TKIP_ENABLED | AES_ENABLED):
            security = "WPA_WPA2_MIXED_MIXED";
            break;
        case(WPA3_SECURITY | AES_ENABLED):
            security = "WPA3_AES_PSK";
            break;
        case(WPA2_SECURITY | WPA3_SECURITY | AES_ENABLED):
            security = "WPA2_WPA3_MIXED";
            break;
        default:
            security = "";
        }
        snprintf(
            infoWifi,
            99,
            "AP: %s\n%s\nChannel: %d    RSSI: %d\nMAC: %s",
            app->wifiList[app->selectedWifi].APssid,
            security,
            app->wifiList[app->selectedWifi].chanel,
            app->wifiList[app->selectedWifi].rssi,
            app->wifiList[app->selectedWifi].APbssid);
        if(app->wifiList[app->selectedWifi].deauth) {
            widget_add_button_element(
                app->widget, GuiButtonTypeCenter, "Stop", info_wifi_button_press, app);
        } else {
            widget_add_button_element(
                app->widget, GuiButtonTypeCenter, "Deauth", info_wifi_button_press, app);
        }
        widget_add_button_element(
            app->widget, GuiButtonTypeRight, "Evil", info_wifi_button_press, app);
        widget_add_button_element(
            app->widget, GuiButtonTypeLeft, "Edit", info_wifi_button_press, app);
    }
    widget_add_string_multiline_element(
        app->widget, 64, 45, AlignCenter, AlignBottom, FontSecondary, infoWifi);

    view_dispatcher_switch_to_view(app->view_dispatcher, wifiInfoView);
}
bool info_wifi_scene_on_event(void* context, SceneManagerEvent event) {
    FURI_LOG_D(TAG, __func__);

    UNUSED(context);
    UNUSED(event);
    return false;
}
void info_wifi_scene_on_exit(void* context) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(context);
}

void portal_type_change_call_back(VariableItem* item) {
    FURI_LOG_D(TAG, __func__);
    int index = variable_item_get_current_value_index(item);
    delfyRTL* app = variable_item_get_context(item);
    variable_item_set_current_value_text(item, captive_portals[index]);
    app->captivePortal = index;

    char cadena[13] = "";
    snprintf(cadena, 13, "PORTAL %d\n", app->captivePortal);
    uart_helper_send(app->uart_helper, cadena, strlen(cadena));

    UNUSED(item);
}

void deauth_reason_change_call_back(VariableItem* item) {
    FURI_LOG_D(TAG, __func__);
    int index = variable_item_get_current_value_index(item);
    delfyRTL* app = variable_item_get_context(item);
    variable_item_set_current_value_text(item, deauth_reasons[index]);
    app->deauthReason = index;

    char cadena[13] = "";
    snprintf(cadena, 13, "REASON %d\n", app->deauthReason);
    uart_helper_send(app->uart_helper, cadena, strlen(cadena));

    UNUSED(item);
}
void config_attack_scene_on_enter(void* context);
void generate_mac_address(unsigned char mac[6]) {
    furi_hal_random_fill_buf(mac, 6);

    mac[0] &= 0xFE;
    mac[0] |= 0x02;
}
void mac_type_change_call_back(VariableItem* item) {
    FURI_LOG_D(TAG, __func__);
    int index = variable_item_get_current_value_index(item);
    delfyRTL* app = variable_item_get_context(item);
    variable_item_set_current_value_text(item, mac_type[index]);
    app->mac_type = index;
    if(app->mac_type == 1) {
        char cadena[26] = "";
        snprintf(cadena, 25, "APMAC %s\n", app->wifiList[app->selectedWifi].APbssid);
        uart_helper_send(app->uart_helper, cadena, strlen(cadena));

    } else if(app->mac_type == 2) {
        unsigned char random_mac[6];
        generate_mac_address(random_mac);
        char cadena[26] = "";

        snprintf(
            cadena,
            25,
            "APMAC %02X:%02X:%02X:%02X:%02X:%02X\n",
            random_mac[0],
            random_mac[1],
            random_mac[2],
            random_mac[3],
            random_mac[4],
            random_mac[5]);
        uart_helper_send(app->uart_helper, cadena, strlen(cadena));

    } else if(app->mac_type == 3) {
        char cadena[26] = "";
        snprintf(cadena, 25, "APMAC %s\n", app->customMac);
        uart_helper_send(app->uart_helper, cadena, strlen(cadena));
    }
    config_attack_scene_on_enter(app);
    UNUSED(item);
}

void mac_addres_change_call_back(void* context, uint32_t index) {
    FURI_LOG_D(TAG, __func__);
    FURI_LOG_D(TAG, "%p %ld", context, index);
    UNUSED(index);
    //UNUSED(context);
    delfyRTL* app = context;

    scene_manager_next_scene(app->scene_manager, aPmacAddresScene);
}

void config_attack_scene_on_enter(void* context) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    VariableItem* item;
    variable_item_list_reset(app->variableList);
    item = variable_item_list_add(
        app->variableList, "Deauth Reason", 25, deauth_reason_change_call_back, app);
    variable_item_set_current_value_index(item, app->deauthReason);
    variable_item_set_current_value_text(item, deauth_reasons[app->deauthReason]);
    item = variable_item_list_add(
        app->variableList, "Portal Type", 4, portal_type_change_call_back, app);
    variable_item_set_current_value_index(item, app->captivePortal);
    variable_item_set_current_value_text(item, captive_portals[app->captivePortal]);

    item =
        variable_item_list_add(app->variableList, "Mac Type", 4, mac_type_change_call_back, app);
    variable_item_set_current_value_index(item, app->mac_type);
    variable_item_set_current_value_text(item, mac_type[app->mac_type]);
    view_dispatcher_switch_to_view(app->view_dispatcher, configAttackView);

    if(app->mac_type == 0) {
        //    item = variable_item_list_add(app->variableList, "-", 1, NULL, NULL);
    } else if(app->mac_type == 3) {
        item = variable_item_list_add(app->variableList, app->customMac, 1, NULL, NULL);
        variable_item_list_set_enter_callback(app->variableList, mac_addres_change_call_back, app);
    }
}
bool config_attack_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false;
}
void config_attack_scene_on_exit(void* context) {
    //delfyRTL* app = context;
    //uart_helper_send(app->uart_helper, "STOP\n", 5);
    UNUSED(context);
}

void evil_creds_scene_on_enter(void* context) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    widget_reset(app->widget);
    widget_add_string_multiline_element(
        app->widget, 64, 4, AlignCenter, AlignTop, FontSecondary, "Credentials");
    widget_add_text_scroll_element(app->widget, 0, 16, 128, 50, credentials);

    view_dispatcher_switch_to_view(app->view_dispatcher, evilCredsView);
    UNUSED(context);
}

bool evil_creds_scene_on_event(void* context, SceneManagerEvent event) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(context);
    UNUSED(event);
    return false;
}

void evil_creds_scene_on_exit(void* context) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    uart_helper_send(app->uart_helper, "STOP\n", 5);
    UNUSED(context);
}

void mac_key_input_byte_input_callback(void* context) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    snprintf(
        app->customMac,
        18,
        "%02X:%02X:%02X:%02X:%02X:%02X",
        app->byte_input_store[0],
        app->byte_input_store[1],
        app->byte_input_store[2],
        app->byte_input_store[3],
        app->byte_input_store[4],
        app->byte_input_store[5]);
    FURI_LOG_D(TAG, app->customMac);

    scene_manager_previous_scene(app->scene_manager);
    UNUSED(context);
}
void custom_ap_mac_scene_on_enter(void* context) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;
    ByteInput* byte_input = app->byteInput;
    byte_input_set_header_text(app->byteInput, "Set the AP MAC");
    byte_input_set_result_callback(
        byte_input, mac_key_input_byte_input_callback, NULL, app, app->byte_input_store, MAC_LENGH);

    view_dispatcher_switch_to_view(app->view_dispatcher, aPmacAddresView);

    UNUSED(context);
}

bool custom_ap_mac_scene_on_event(void* context, SceneManagerEvent event) {
    FURI_LOG_D(TAG, __func__);

    UNUSED(context);
    UNUSED(event);
    return false;
}

void custom_ap_mac_scene_on_exit(void* context) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(context);
}

void custom_beacon_scene_on_enter(void* context) {
    delfyRTL* app = context;
    text_input_reset(app->text_input);
    text_input_set_header_text(app->text_input, "Acces Point Name");
    text_input_set_result_callback(
        app->text_input,
        beacon_networks_text_input_callback,
        app,
        app->ssidAP,
        app->ssidAPLength,
        true);

    view_dispatcher_switch_to_view(app->view_dispatcher, bssidTextInputView);
    UNUSED(context);
}

bool custom_beacon_scene_on_event(void* context, SceneManagerEvent event) {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = context;

    FURI_LOG_I("delfyRTL", "%s event.type: %d", __func__, event.type);
    FURI_LOG_I("delfyRTL", "%s event.event: %ldd", __func__, event.event);
    char cadena[40];
    switch(event.type) {
    case SceneManagerEventTypeCustom:
        switch(event.event) {
        case SsidAPInputSceneSaveEvent:
            FURI_LOG_D(TAG, "ssidAPLenght %d", strlen(app->ssidAP));

            snprintf(cadena, 6 + strlen(app->ssidAP) + 2, "BSSID %s\n", app->ssidAP);
            uart_helper_send(app->uart_helper, cadena, sizeof(cadena));
            FURI_LOG_D(TAG, cadena);
            scene_manager_next_scene(app->scene_manager, beaconInfoScene);
            break;
        }
        return true;
    default:
        break;
    }
    return false;
}

void custom_beacon_scene_on_exit(void* context) {
    UNUSED(context);
}

void beacon_info_scene_on_enter(void* context) {
    delfyRTL* app = context;
    widget_reset(app->widget);

    switch(app->submenuIndex) {
    case 0:
        widget_add_string_element(
            app->widget, 64, 10, AlignCenter, AlignTop, FontPrimary, app->ssidAP);
        break;
    case 1:
        widget_add_string_element(
            app->widget, 64, 10, AlignCenter, AlignTop, FontPrimary, "Random");
        break;
    case 2:
        widget_add_string_element(
            app->widget, 90, 10, AlignCenter, AlignTop, FontPrimary, "RickRoll");
        widget_add_icon_element(app->widget, 0, 0, rick[0]);
        furi_timer_start(app->timer, 300);
        break;
    }
    view_dispatcher_switch_to_view(app->view_dispatcher, beaconInfoView);
}

bool beacon_info_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false;
}

void beacon_info_scene_on_exit(void* context) {
    UNUSED(context);
    delfyRTL* app = context;
    furi_timer_stop(app->timer);
    uart_helper_send(app->uart_helper, "STOP\n", 5);
}

void help_scene_on_enter(void* context) {
    delfyRTL* app = context;
    app->menuIndex = 3;
    widget_reset(app->widget);
    widget_add_text_scroll_element(
        app->widget, 0, 0, 128, 64, "https://github.com/gorebrau/delfyRTL");
    view_dispatcher_switch_to_view(app->view_dispatcher, helpView);
}

bool help_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false;
}

void help_scene_on_exit(void* context) {
    UNUSED(context);
}

//Array de Event Handlers
void (*const delfyRTL_scene_on_enter_handlers[])(void*) = {
    main_menu_scene_on_enter,
    scan_networks_scene_on_enter,
    list_networks_scene_on_enter,
    info_wifi_scene_on_enter,
    config_attack_scene_on_enter,
    evil_creds_scene_on_enter,
    custom_ap_mac_scene_on_enter,
    beacon_network_scene_on_enter,
    custom_beacon_scene_on_enter,
    beacon_info_scene_on_enter,
    help_scene_on_enter};

bool (*const delfyRTL_scene_on_event_handlers[])(void*, SceneManagerEvent) = {
    main_menu_scene_on_event,
    scan_networks_scene_on_event,
    list_networks_scene_on_event,
    info_wifi_scene_on_event,
    config_attack_scene_on_event,
    evil_creds_scene_on_event,
    custom_ap_mac_scene_on_event,
    beacon_network_scene_on_event,
    custom_beacon_scene_on_event,
    beacon_info_scene_on_event,
    help_scene_on_event};

void (*const delfyRTL_scene_on_exit_handlers[])(void*) = {
    main_menu_scene_on_exit,
    scan_networks_scene_on_exit,
    list_networks_scene_on_exit,
    info_wifi_scene_on_exit,
    config_attack_scene_on_exit,
    evil_creds_scene_on_exit,
    custom_ap_mac_scene_on_exit,
    beacon_network_scene_on_exit,
    custom_beacon_scene_on_exit,
    beacon_info_scene_on_exit,
    help_scene_on_exit};

static const SceneManagerHandlers delfyRTL_scene_manager_handlers = {
    .on_enter_handlers = delfyRTL_scene_on_enter_handlers,
    .on_event_handlers = delfyRTL_scene_on_event_handlers,
    .on_exit_handlers = delfyRTL_scene_on_exit_handlers,
    .scene_num = DelfyRTLSceneCount,
};

static bool delfyRTL_custom_callback(void* context, uint32_t custom_event) {
    FURI_LOG_D(TAG, __func__);
    furi_assert(context);
    delfyRTL* app = context;
    return scene_manager_handle_custom_event(app->scene_manager, custom_event);
}

bool delfyRTL_back_event_callback(void* context) {
    FURI_LOG_D(TAG, __func__);
    furi_assert(context);
    delfyRTL* app = context;
    return scene_manager_handle_back_event(app->scene_manager);
}

void uart_process_line(FuriString* line, void* context) {
    FURI_LOG_D(TAG, __func__);
    FURI_LOG_D(TAG, furi_string_get_cstr(line));
    delfyRTL* app = context;
    if(strncmp(furi_string_get_cstr(line), "AP:", 3) == 0) {
        char buffer[128]; // Pequeño buffer en la pila (Flipper Zero tiene RAM limitada)
        strncpy(buffer, furi_string_get_cstr(line), sizeof(buffer) - 1);
        buffer[sizeof(buffer) - 1] = '\0'; // Asegurar terminación nula

        char* token = strtok(buffer, ":|"); // Omitir "AP:"
        if(!token) return;

        // Crear un nuevo espacio en la lista
        APDetails* temp = realloc(app->wifiList, (app->wifiCount + 1) * sizeof(APDetails));
        if(!temp) {
            printf("Error de memoria\n");
            return;
        }
        app->wifiList = temp;
        APDetails* newAP = &app->wifiList[app->wifiCount];

        // Extraer los valores
        token = strtok(NULL, "|"); // ID del AP
        if(!token) return;
        newAP->idAP = atoi(token);

        token = strtok(NULL, "|"); // SSID
        if(!token) return;
        newAP->APssid = malloc(strlen(token) + 1);
        if(!newAP->APssid) return;
        strcpy(newAP->APssid, token);

        token = strtok(NULL, "|"); // BSSID
        if(!token) return;
        strncpy(newAP->APbssid, token, 17);
        newAP->APbssid[17] = '\0';

        token = strtok(NULL, "|"); // Canal
        if(!token) return;
        newAP->chanel = atoi(token);

        token = strtok(NULL, "|"); // RSSI
        if(!token) return;
        newAP->security = atoi(token);

        token = strtok(NULL, "|"); // RSSI
        if(!token) return;
        newAP->rssi = atoi(token);

        newAP->deauth = false;

        app->wifiCount++;
    } else if(strncmp(furi_string_get_cstr(line), "SCAN:OK", 7) == 0) {
        scanFinish = true;
        FURI_LOG_D(TAG, "SCAN FINISH");
    } else if(strncmp(furi_string_get_cstr(line), "EV:", 3) == 0) {
        char buffer[128]; // Pequeño buffer en la pila (Flipper Zero tiene RAM limitada)
        strncpy(buffer, furi_string_get_cstr(line), sizeof(buffer) - 1);
        char* token = strtok(buffer, ":|"); // Omitir "AP:"
        if(!token) return;
        token = strtok(NULL, "|");
        strcat(credentials, token);
        strcat(credentials, "\n");
        evil_creds_scene_on_enter(app);
    }
}

static void animation_timer_callback(void* context) {
    delfyRTL* app = context;
    if(app->rickIndex % 4 == 0) {
        widget_reset(app->widget);
        widget_add_string_element(
            app->widget, 90, 10, AlignCenter, AlignTop, FontPrimary, "RickRoll");
        if(app->rickIndex >= 8) {
            widget_add_string_multiline_element(
                app->widget,
                128,
                30,
                AlignRight,
                AlignCenter,
                FontSecondary,
                "Never gonna\ngive you up");
        }
        if(app->rickIndex >= 16) {
            widget_add_string_multiline_element(
                app->widget,
                64,
                53,
                AlignLeft,
                AlignCenter,
                FontSecondary,
                "Never gonna\nlet you down");
        }
    }
    app->rickIndex = (app->rickIndex + 1) % 24;

    widget_add_icon_element(app->widget, 0, 0, rick[app->rickIndex]);

    //furi_timer_start(app->timer, 300);
}

static delfyRTL* app_alloc() {
    FURI_LOG_D(TAG, __func__);
    delfyRTL* app = malloc(sizeof(delfyRTL));
    app->ssidAPLength = 32;
    app->ssidAP = malloc(app->ssidAPLength);
    app->wifiList = NULL;
    app->ssidAPLength = 0;
    app->captivePortal = 0;
    app->deauthReason = 2;
    app->mac_type = 0;
    app->scene_manager = scene_manager_alloc(&delfyRTL_scene_manager_handlers, app);
    app->view_dispatcher = view_dispatcher_alloc();
    strncpy(app->customMac, "11:22:33:44:55:66", 18);
    app->byte_input_store[0] = 0x11;
    app->byte_input_store[1] = 0x22;
    app->byte_input_store[2] = 0x33;
    app->byte_input_store[3] = 0x44;
    app->byte_input_store[4] = 0x55;
    app->byte_input_store[5] = 0x66;

    view_dispatcher_set_event_callback_context(app->view_dispatcher, app);
    view_dispatcher_set_custom_event_callback(app->view_dispatcher, delfyRTL_custom_callback);
    view_dispatcher_set_navigation_event_callback(
        app->view_dispatcher, delfyRTL_back_event_callback);

    app->menu = menu_alloc();
    view_dispatcher_add_view(app->view_dispatcher, mainMenuView, menu_get_view(app->menu));

    app->submenu = submenu_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, scannedWifisView, submenu_get_view(app->submenu));
    view_dispatcher_add_view(app->view_dispatcher, beaconListView, submenu_get_view(app->submenu));

    app->text_input = text_input_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, bssidTextInputView, text_input_get_view(app->text_input));

    app->loading = loading_alloc();
    view_dispatcher_add_view(app->view_dispatcher, loadingView, loading_get_view(app->loading));

    app->widget = widget_alloc();
    view_dispatcher_add_view(app->view_dispatcher, wifiInfoView, widget_get_view(app->widget));
    view_dispatcher_add_view(app->view_dispatcher, evilCredsView, widget_get_view(app->widget));
    view_dispatcher_add_view(app->view_dispatcher, beaconInfoView, widget_get_view(app->widget));
    view_dispatcher_add_view(app->view_dispatcher, helpView, widget_get_view(app->widget));

    app->variableList = variable_item_list_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, configAttackView, variable_item_list_get_view(app->variableList));

    app->byteInput = byte_input_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, aPmacAddresView, byte_input_get_view(app->byteInput));

    app->uart_helper = uart_helper_alloc();
    uart_helper_set_baud_rate(app->uart_helper, DEVICE_BAUDRATE);
    uart_helper_set_delimiter(app->uart_helper, LINE_DELIMITER, INCLUDE_LINE_DELIMITER);
    uart_helper_set_callback(app->uart_helper, uart_process_line, app);

    app->timer = furi_timer_alloc(animation_timer_callback, FuriTimerTypePeriodic, app);
    return app;
}

void delfyRTL_wifimenu_callback(void* context, uint32_t index) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(context);
    UNUSED(index);
}

static void app_free(delfyRTL* app) {
    FURI_LOG_D(TAG, __func__);
    furi_assert(app);

    uart_helper_free(app->uart_helper);

    view_dispatcher_remove_view(app->view_dispatcher, mainMenuView);
    view_dispatcher_remove_view(app->view_dispatcher, scannedWifisView);
    view_dispatcher_remove_view(app->view_dispatcher, bssidTextInputView);
    view_dispatcher_remove_view(app->view_dispatcher, loadingView);
    view_dispatcher_remove_view(app->view_dispatcher, wifiInfoView);
    view_dispatcher_remove_view(app->view_dispatcher, configAttackView);
    view_dispatcher_remove_view(app->view_dispatcher, evilCredsView);
    view_dispatcher_remove_view(app->view_dispatcher, aPmacAddresView);
    view_dispatcher_remove_view(app->view_dispatcher, beaconListView);
    view_dispatcher_remove_view(app->view_dispatcher, beaconInfoView);
    view_dispatcher_remove_view(app->view_dispatcher, helpView);

    scene_manager_free(app->scene_manager);

    view_dispatcher_free(app->view_dispatcher); //Some events whre not processed

    furi_timer_free(app->timer);

    menu_free(app->menu);
    submenu_free(app->submenu);

    text_input_free(app->text_input);
    loading_free(app->loading);
    for(int i = 0; i < app->wifiCount; i++) {
        free(app->wifiList[i].APssid); // Liberar memoria del SSID
    }

    free(app->wifiList); // Liberar el array dinámico
    app->wifiList = NULL; // Evitar punteros colgantes
    app->wifiCount = 0; // Resetear el contador
    app->rickIndex = 0;

    free(app->ssidAP);
    furi_record_close(RECORD_GUI);
    furi_hal_power_disable_otg();
    free(app);
}

int32_t delfyRTL_app(void* p) {
    FURI_LOG_D(TAG, __func__);
    UNUSED(p);

    delfyRTL* app = app_alloc();
    Expansion* expansion = furi_record_open(RECORD_EXPANSION);
    expansion_disable(expansion);
    if(!furi_hal_power_is_otg_enabled()) furi_hal_power_enable_otg();
    Gui* gui = furi_record_open(RECORD_GUI);
    view_dispatcher_attach_to_gui(app->view_dispatcher, gui, ViewDispatcherTypeFullscreen);
    scene_manager_next_scene(app->scene_manager, mainMenuScene);
    view_dispatcher_run(app->view_dispatcher);

    app_free(app);
    expansion_enable(expansion);

    furi_record_close(RECORD_EXPANSION);

    return 0;
}
