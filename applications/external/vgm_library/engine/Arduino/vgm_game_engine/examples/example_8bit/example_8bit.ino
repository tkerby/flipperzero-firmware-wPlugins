#include <Arduino.h>
#include "VGMGameEngine.h"
/*
    Board Manager: Raspberry Pi Pico
    Flash Size: 2MB (Sketch: 1984KB, FS: 64KB)
    CPU Speed: 200MHz
*/
auto board = VGMConfig; // Video Game Module Configuration
const PROGMEM uint8_t player_20x16px[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xED, 0xED, 0xF2, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xE9, 0xC0, 0xC0, 0xE4, 0xF6, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xC4, 0xFB, 0xFF, 0xFF, 0xFF, 0xFB, 0xC4, 0xE5, 0xE9, 0xEA, 0xE9, 0xC4, 0xF6, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xC0, 0xC4, 0xF6, 0xFF, 0xF6, 0xC4, 0xE5, 0xE9, 0xF2, 0xFF, 0xFB, 0xFB, 0xE9, 0xF2, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xC0, 0xE5, 0xE9, 0xF6, 0xF6, 0xC0, 0xE5, 0xF2, 0xFF, 0xDB, 0x6D, 0xFB, 0xC9, 0xF2, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xC0, 0xE5, 0xE5, 0xE9, 0xE9, 0xC0, 0xE9, 0xFB, 0xFF, 0xD6, 0x92, 0xFF, 0xF1, 0xF1, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xC0, 0xE5, 0xEA, 0xE5, 0xC0, 0xC0, 0xE9, 0xFB, 0xFB, 0xFB, 0xFF, 0xF6, 0xF5, 0xF9, 0xFA, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xC0, 0xE5, 0xEA, 0xE5, 0xE5, 0xC0, 0xE9, 0xF7, 0xFF, 0xFB, 0xF6, 0xC9, 0xF6, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xC4, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE9, 0xEA, 0xE9, 0xC4, 0xC9, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 0xE4, 0xC0, 0xE5, 0xEA, 0xE9, 0xED, 0xF0, 0xEC, 0xEC, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF2, 0xC4, 0xE0, 0xE9, 0xED, 0xF4, 0xF4, 0xF4, 0xF4, 0xF5, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xF6, 0xF6, 0xF6, 0xC4, 0xE0, 0xED, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF2, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE9, 0xF4, 0xF4, 0xF4, 0xF4, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF2, 0xC0, 0xE5, 0xE5, 0xE5, 0xE5, 0xE8, 0xF4, 0xF4, 0xF4, 0xFA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF2, 0xC0, 0xC0, 0xC0, 0xC0, 0xED, 0xFB, 0xFE, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xED, 0xED, 0xED, 0xED, 0xF6, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

/* Update the player entity using current game input */
void player_update(Entity *self, Game *game)
{
    Vector oldPos = self->position;
    Vector newPos = oldPos;

    // Move according to input
    if (game->input == BUTTON_UP)
        newPos.y -= 10;
    else if (game->input == BUTTON_DOWN)
        newPos.y += 10;
    else if (game->input == BUTTON_LEFT)
        newPos.x -= 10;
    else if (game->input == BUTTON_RIGHT)
        newPos.x += 10;

    // set new position
    self->position_set(newPos);

    // check if new position is within the level boundaries
    if (newPos.x < 0 || newPos.x + self->size.x > game->current_level->size.x ||
        newPos.y < 0 || newPos.y + self->size.y > game->current_level->size.y)
    {
        // restore old position
        self->position_set(oldPos);
    }

    // Store the current camera position before updating
    game->old_pos = game->pos;

    // Update camera position to center the player
    float camera_x = self->position.x - (game->size.x / 2);
    float camera_y = self->position.y - (game->size.y / 2);

    // Clamp camera position to the world boundaries
    camera_x = constrain(camera_x, 0, game->current_level->size.x - game->size.x);
    camera_y = constrain(camera_y, 0, game->current_level->size.y - game->size.y);

    // Set the new camera position
    game->pos = Vector(camera_x, camera_y);
}

/* Render the player entity along with game information */
void player_render(Entity *player, Draw *draw, Game *game)
{
    /*
        Draw anything extra here
        The engine will draw the player entity
    */
    game->draw->text(Vector(110, 10), "VGM Game Engine");
}

void setup()
{
    // Setup file system (must be called in setup)
    setup_fs();

    // Create the game instance with its name, start/stop callbacks, and colors.
    Game *game = new Game(
        "VGM Game Engine",                 // Game name
        Vector(board.width, board.height), // Game size
        NULL,                              // start callback
        NULL,                              // stop callback
        TFT_RED,                           // Foreground color
        TFT_WHITE,                         // Background color
        true,                              // Use 8-bit graphics?
        board,                             // Board configuration
        true                               // Use double buffering for TFT
    );

    // set world size
    game->world_size = game->size;

    // UART buttons
    ButtonUART *uart = new ButtonUART();

    // Add input buttons
    game->input_add(new Input(uart));

    // Create and add a level to the game.
    Level *level = new Level("Level 1", Vector(board.width, board.height), game);
    game->level_add(level);

    Entity *player = new Entity(
        "Player",
        ENTITY_PLAYER,
        Vector(160, 120), // Initial position
        Vector(20, 16),
        player_20x16px,
        NULL,          // No sprite left
        NULL,          // No sprite right
        NULL,          // No custom initialization routine
        NULL,          // No custom destruction routine
        player_update, // Update callback
        player_render, // Render callback
        NULL,          // No collision callback
        true           // 8-bit sprite
    );

    // Add the player entity to the level
    level->entity_add(player);

    // Create the game engine (with 30 frames per second target).
    GameEngine *engine = new GameEngine("VGM Game Engine", 30, game);

    // Run the game engine's main loop.
    engine->run();
}

void loop()
{
    // nothing to do here
}
