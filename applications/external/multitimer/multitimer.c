#include <furi.h>
#include <furi_hal.h>
#include <furi_hal_rtc.h>
#include <gui/gui.h>
#include <gui/view.h>
#include <gui/view_dispatcher.h>
#include <gui/modules/submenu.h>
#include <gui/modules/variable_item_list.h>
#include <gui/modules/text_input.h>
#include <gui/modules/popup.h>
#include <input/input.h>
#include <notification/notification_messages.h>
#include <storage/storage.h>
#include <toolbox/saved_struct.h>

/* generated by fbt from .png files in images folder */
#include <multitimer_icons.h>

#define TAG             "MultiTimer"
#define MAX_TIMERS      10
#define TIMER_DATA_PATH APP_DATA_PATH("multitimer")
#define TIMER_DATA_FILE TIMER_DATA_PATH "/timers.dat"

typedef enum {
    MultiTimerViewSubmenu,
    MultiTimerViewTimerSetup,
    MultiTimerViewTimerRunning,
    MultiTimerViewTimerList,
    MultiTimerViewTimerFinished,
    MultiTimerViewWelcomePopup,
} MultiTimerView;

typedef enum {
    MultiTimerEventTypeKey,
    MultiTimerEventTypeTick,
} MultiTimerEventType;

typedef struct {
    MultiTimerEventType type;
    InputEvent input;
} MultiTimerEvent;

typedef enum {
    TimerStateSetup,
    TimerStateRunning,
    TimerStatePaused,
    TimerStateFinished,
} TimerState;

typedef struct {
    bool active;
    char name[32];
    uint32_t start_timestamp;
    uint32_t duration_seconds;
    TimerState state;
} TimerData;

typedef struct {
    uint32_t magic;
    uint32_t version;
    uint32_t count;
    TimerData timers[MAX_TIMERS];
} TimerStorage;

typedef struct {
    Gui* gui;
    ViewDispatcher* view_dispatcher;
    Submenu* submenu;
    View* timer_setup_view;
    View* timer_running_view;
    View* timer_list_view;
    View* timer_finished_view;
    Popup* welcome_popup;
    NotificationApp* notifications;
    Storage* storage;

    // Timer data
    TimerStorage timer_storage;

    // Current timer setup state
    TimerState state;
    uint32_t setup_hours;
    uint32_t setup_minutes;
    uint32_t setup_seconds;
    uint8_t setup_selection; // 0=hours, 1=minutes, 2=seconds
    char timer_name[32];

    // Active timer viewing
    int selected_timer_index;

    FuriTimer* tick_timer;
    bool timer_running;
} MultiTimerApp;

// Preset timer options (in seconds)
static const uint32_t preset_times[] = {
    60, // 1 minute
    300, // 5 minutes
    600, // 10 minutes
    900, // 15 minutes
    1200, // 20 minutes
    1800, // 30 minutes
    3600, // 1 hour
};

static const char* preset_names[] = {
    "1 minute",
    "5 minutes",
    "10 minutes",
    "15 minutes",
    "20 minutes",
    "30 minutes",
    "1 hour",
};

#define TIMER_STORAGE_MAGIC   0x54494D52 // "TIMR"
#define TIMER_STORAGE_VERSION 1

// Forward declarations
static void multitimer_app_free(MultiTimerApp* app);
static void save_timer_data(MultiTimerApp* app);
static void load_timer_data(MultiTimerApp* app);
static void check_expired_timers(MultiTimerApp* app);
static uint32_t get_remaining_seconds(TimerData* timer);
static int find_free_timer_slot(MultiTimerApp* app);

// Timer storage functions
static void save_timer_data(MultiTimerApp* app) {
    if(!app || !app->storage) return;

    app->timer_storage.magic = TIMER_STORAGE_MAGIC;
    app->timer_storage.version = TIMER_STORAGE_VERSION;

    Storage* storage = app->storage;
    storage_common_mkdir(storage, TIMER_DATA_PATH);

    File* file = storage_file_alloc(storage);
    if(!file) return;

    if(storage_file_open(file, TIMER_DATA_FILE, FSAM_WRITE, FSOM_CREATE_ALWAYS)) {
        storage_file_write(file, &app->timer_storage, sizeof(TimerStorage));
    }
    storage_file_close(file);
    storage_file_free(file);
}

static void load_timer_data(MultiTimerApp* app) {
    if(!app || !app->storage) return;

    Storage* storage = app->storage;
    File* file = storage_file_alloc(storage);
    if(!file) {
        // Initialize with empty data if allocation fails
        memset(&app->timer_storage, 0, sizeof(TimerStorage));
        return;
    }

    if(storage_file_open(file, TIMER_DATA_FILE, FSAM_READ, FSOM_OPEN_EXISTING)) {
        storage_file_read(file, &app->timer_storage, sizeof(TimerStorage));

        if(app->timer_storage.magic != TIMER_STORAGE_MAGIC ||
           app->timer_storage.version != TIMER_STORAGE_VERSION) {
            // Invalid data, reset
            memset(&app->timer_storage, 0, sizeof(TimerStorage));
        }
    } else {
        // No saved data, initialize
        memset(&app->timer_storage, 0, sizeof(TimerStorage));
    }

    storage_file_close(file);
    storage_file_free(file);
}

static uint32_t get_remaining_seconds(TimerData* timer) {
    if(!timer || !timer->active || timer->state != TimerStateRunning) {
        return timer ? timer->duration_seconds : 0;
    }

    uint32_t current_timestamp = furi_hal_rtc_get_timestamp();
    uint32_t elapsed = current_timestamp - timer->start_timestamp;

    if(elapsed >= timer->duration_seconds) {
        return 0;
    }

    return timer->duration_seconds - elapsed;
}

static void check_expired_timers(MultiTimerApp* app) {
    if(!app) return;

    bool has_expired = false;

    for(int i = 0; i < MAX_TIMERS; i++) {
        TimerData* timer = &app->timer_storage.timers[i];
        if(timer->active && timer->state == TimerStateRunning) {
            if(get_remaining_seconds(timer) == 0) {
                timer->state = TimerStateFinished;
                has_expired = true;
                FURI_LOG_I(TAG, "Timer '%s' expired", timer->name);
            }
        }
    }

    if(has_expired && app->notifications) {
        notification_message(app->notifications, &sequence_audiovisual_alert);
        save_timer_data(app);
    }
}

static int find_free_timer_slot(MultiTimerApp* app) {
    if(!app) return -1;

    for(int i = 0; i < MAX_TIMERS; i++) {
        if(!app->timer_storage.timers[i].active) {
            return i;
        }
    }
    return -1;
}

// Timer tick callback
static void timer_tick_callback(void* context) {
    MultiTimerApp* app = context;
    if(!app) return;

    check_expired_timers(app);

    // Update current view if it's timer related
    if(app->view_dispatcher) {
        // Force view update for timer views
        if(app->timer_running_view) {
            view_commit_model(app->timer_running_view, false);
        }
        if(app->timer_list_view) {
            view_commit_model(app->timer_list_view, false);
        }
    }
}

// Format time as HH:MM:SS
static void format_time(uint32_t seconds, char* buffer, size_t buffer_size) {
    if(!buffer || buffer_size == 0) return;

    uint32_t hours = seconds / 3600;
    uint32_t minutes = (seconds % 3600) / 60;
    uint32_t secs = seconds % 60;
    snprintf(buffer, buffer_size, "%02lu:%02lu:%02lu", hours, minutes, secs);
}

// Timer setup view
static void timer_setup_draw_callback(Canvas* canvas, void* model) {
    MultiTimerApp* app = model;
    if(!app || !canvas) return;

    canvas_clear(canvas);
    canvas_set_font(canvas, FontPrimary);

    // Draw clock icon next to title
    canvas_draw_icon(canvas, 45, 3, &I_clock_10x10);
    canvas_draw_str_aligned(canvas, 64, 5, AlignCenter, AlignTop, "New Timer");

    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str_aligned(
        canvas, 64, 20, AlignCenter, AlignTop, "Left/Right: change, Up/Down: select");

    // Draw time inputs
    char time_str[32];
    canvas_set_font(canvas, FontBigNumbers);

    // Hours
    snprintf(time_str, sizeof(time_str), "%02lu", app->setup_hours);
    if(app->setup_selection == 0) {
        canvas_draw_box(canvas, 15, 35, 20, 20);
        canvas_set_color(canvas, ColorWhite);
    }
    canvas_draw_str_aligned(canvas, 25, 45, AlignCenter, AlignCenter, time_str);
    canvas_set_color(canvas, ColorBlack);

    canvas_draw_str_aligned(canvas, 40, 45, AlignCenter, AlignCenter, ":");

    // Minutes
    snprintf(time_str, sizeof(time_str), "%02lu", app->setup_minutes);
    if(app->setup_selection == 1) {
        canvas_draw_box(canvas, 50, 35, 20, 20);
        canvas_set_color(canvas, ColorWhite);
    }
    canvas_draw_str_aligned(canvas, 60, 45, AlignCenter, AlignCenter, time_str);
    canvas_set_color(canvas, ColorBlack);

    canvas_draw_str_aligned(canvas, 75, 45, AlignCenter, AlignCenter, ":");

    // Seconds
    snprintf(time_str, sizeof(time_str), "%02lu", app->setup_seconds);
    if(app->setup_selection == 2) {
        canvas_draw_box(canvas, 85, 35, 20, 20);
        canvas_set_color(canvas, ColorWhite);
    }
    canvas_draw_str_aligned(canvas, 95, 45, AlignCenter, AlignCenter, time_str);
    canvas_set_color(canvas, ColorBlack);

    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str_aligned(canvas, 25, 28, AlignCenter, AlignTop, "HH");
    canvas_draw_str_aligned(canvas, 60, 28, AlignCenter, AlignTop, "MM");
    canvas_draw_str_aligned(canvas, 95, 28, AlignCenter, AlignTop, "SS");

    // Instructions
    canvas_draw_str_aligned(canvas, 64, 58, AlignCenter, AlignTop, "OK: Start  Back: Cancel");
}

static bool timer_setup_input_callback(InputEvent* event, void* context) {
    MultiTimerApp* app = context;
    if(!app || !event) return false;

    if(event->type == InputTypePress) {
        switch(event->key) {
        case InputKeyLeft:
            if(app->setup_selection == 0) { // Hours
                if(app->setup_hours > 0) app->setup_hours--;
            } else if(app->setup_selection == 1) { // Minutes
                if(app->setup_minutes > 0) app->setup_minutes--;
            } else if(app->setup_selection == 2) { // Seconds
                if(app->setup_seconds > 0) app->setup_seconds--;
            }
            return true;

        case InputKeyRight:
            if(app->setup_selection == 0) { // Hours
                if(app->setup_hours < 23) app->setup_hours++;
            } else if(app->setup_selection == 1) { // Minutes
                if(app->setup_minutes < 59) app->setup_minutes++;
            } else if(app->setup_selection == 2) { // Seconds
                if(app->setup_seconds < 59) app->setup_seconds++;
            }
            return true;

        case InputKeyUp:
            if(app->setup_selection > 0) app->setup_selection--;
            return true;

        case InputKeyDown:
            if(app->setup_selection < 2) app->setup_selection++;
            return true;

        case InputKeyOk: {
            // Create new timer
            uint32_t duration =
                app->setup_hours * 3600 + app->setup_minutes * 60 + app->setup_seconds;
            if(duration > 0) {
                int slot = find_free_timer_slot(app);
                if(slot >= 0) {
                    TimerData* timer = &app->timer_storage.timers[slot];
                    timer->active = true;
                    timer->start_timestamp = furi_hal_rtc_get_timestamp();
                    timer->duration_seconds = duration;
                    timer->state = TimerStateRunning;

                    // Generate timer name
                    char duration_str[32];
                    format_time(duration, duration_str, sizeof(duration_str));
                    snprintf(timer->name, sizeof(timer->name), "%s", duration_str);

                    app->timer_storage.count++;
                    save_timer_data(app);

                    app->selected_timer_index = slot;
                    if(app->view_dispatcher) {
                        view_dispatcher_switch_to_view(
                            app->view_dispatcher, MultiTimerViewTimerRunning);
                    }
                }
            }
            return true;
        }

        case InputKeyBack:
            if(app->view_dispatcher) {
                view_dispatcher_switch_to_view(app->view_dispatcher, MultiTimerViewSubmenu);
            }
            return true;

        default:
            break;
        }
    }

    return false;
}

// Timer running view
static void timer_running_draw_callback(Canvas* canvas, void* model) {
    MultiTimerApp* app = model;
    if(!app || !canvas) return;

    canvas_clear(canvas);
    canvas_set_font(canvas, FontPrimary);

    if(app->selected_timer_index >= 0 && app->selected_timer_index < MAX_TIMERS) {
        TimerData* timer = &app->timer_storage.timers[app->selected_timer_index];

        if(timer->active) {
            // Draw hourglass icon next to timer name
            canvas_draw_icon(canvas, 35, 3, &I_hourglass_10x10);
            canvas_draw_str_aligned(canvas, 64, 5, AlignCenter, AlignTop, timer->name);

            // Draw remaining time
            char time_str[32];
            uint32_t remaining = get_remaining_seconds(timer);
            format_time(remaining, time_str, sizeof(time_str));

            canvas_set_font(canvas, FontBigNumbers);
            canvas_draw_str_aligned(canvas, 64, 30, AlignCenter, AlignCenter, time_str);

            // Draw progress bar
            uint32_t elapsed = timer->duration_seconds - remaining;
            if(timer->duration_seconds > 0) {
                uint32_t progress_width =
                    (uint32_t)((float)elapsed / timer->duration_seconds * 110);
                canvas_draw_frame(canvas, 9, 45, 110, 8);
                if(progress_width > 0) {
                    canvas_draw_box(canvas, 10, 46, progress_width, 6);
                }
            }

            // Instructions
            canvas_set_font(canvas, FontSecondary);
            if(timer->state == TimerStateRunning) {
                canvas_draw_str_aligned(
                    canvas, 64, 58, AlignCenter, AlignTop, "OK: Pause  Back: Stop");
            } else if(timer->state == TimerStatePaused) {
                canvas_draw_str_aligned(
                    canvas, 64, 58, AlignCenter, AlignTop, "OK: Resume  Back: Stop");
            } else if(timer->state == TimerStateFinished) {
                canvas_set_font(canvas, FontPrimary);
                canvas_draw_str_aligned(canvas, 64, 20, AlignCenter, AlignTop, "FINISHED!");
                canvas_set_font(canvas, FontSecondary);
                canvas_draw_str_aligned(
                    canvas, 64, 58, AlignCenter, AlignTop, "Press any key to dismiss");
            }
        }
    }
}

static bool timer_running_input_callback(InputEvent* event, void* context) {
    MultiTimerApp* app = context;
    if(!app || !event) return false;

    if(event->type == InputTypePress) {
        if(app->selected_timer_index >= 0 && app->selected_timer_index < MAX_TIMERS) {
            TimerData* timer = &app->timer_storage.timers[app->selected_timer_index];

            if(timer->state == TimerStateFinished) {
                // Timer finished, dismiss it
                timer->active = false;
                app->timer_storage.count--;
                save_timer_data(app);
                if(app->view_dispatcher) {
                    view_dispatcher_switch_to_view(app->view_dispatcher, MultiTimerViewTimerList);
                }
                return true;
            }

            switch(event->key) {
            case InputKeyOk:
                if(timer->state == TimerStateRunning) {
                    timer->state = TimerStatePaused;
                    // Store the remaining time when paused
                    uint32_t remaining = get_remaining_seconds(timer);
                    timer->duration_seconds = remaining;
                    timer->start_timestamp = furi_hal_rtc_get_timestamp();
                } else if(timer->state == TimerStatePaused) {
                    timer->state = TimerStateRunning;
                    timer->start_timestamp = furi_hal_rtc_get_timestamp();
                }
                save_timer_data(app);
                return true;

            case InputKeyBack:
                // Stop timer
                timer->active = false;
                app->timer_storage.count--;
                save_timer_data(app);
                if(app->view_dispatcher) {
                    view_dispatcher_switch_to_view(app->view_dispatcher, MultiTimerViewTimerList);
                }
                return true;

            default:
                break;
            }
        }
    }

    return false;
}

// Timer list view
static void timer_list_draw_callback(Canvas* canvas, void* model) {
    MultiTimerApp* app = model;
    if(!app || !canvas) return;

    canvas_clear(canvas);
    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str_aligned(canvas, 64, 5, AlignCenter, AlignTop, "Active Timers");

    canvas_set_font(canvas, FontSecondary);

    int y_pos = 20;
    int active_count = 0;

    for(int i = 0; i < MAX_TIMERS; i++) {
        TimerData* timer = &app->timer_storage.timers[i];
        if(timer->active) {
            active_count++;

            char display_str[64];
            char time_str[32];
            uint32_t remaining = get_remaining_seconds(timer);
            format_time(remaining, time_str, sizeof(time_str));

            const char* state_str = "";
            if(timer->state == TimerStateRunning) {
                state_str = ">";
            } else if(timer->state == TimerStatePaused) {
                state_str = "||";
            } else if(timer->state == TimerStateFinished) {
                state_str = "!";
            }

            snprintf(display_str, sizeof(display_str), "%s %s", state_str, time_str);
            canvas_draw_str(canvas, 5, y_pos, display_str);
            y_pos += 10;

            if(y_pos > 60) break; // Don't overflow screen
        }
    }

    if(active_count == 0) {
        canvas_draw_str_aligned(canvas, 64, 35, AlignCenter, AlignCenter, "No active timers");
    }

    canvas_draw_str_aligned(canvas, 64, 62, AlignCenter, AlignTop, "Back: Menu");
}

static bool timer_list_input_callback(InputEvent* event, void* context) {
    MultiTimerApp* app = context;
    if(!app || !event) return false;

    if(event->type == InputTypePress) {
        switch(event->key) {
        case InputKeyBack:
            if(app->view_dispatcher) {
                view_dispatcher_switch_to_view(app->view_dispatcher, MultiTimerViewSubmenu);
            }
            return true;

        default:
            break;
        }
    }

    return false;
}

// Welcome popup callback
static void welcome_popup_callback(void* context) {
    MultiTimerApp* app = context;
    if(!app || !app->view_dispatcher) return;
    view_dispatcher_switch_to_view(app->view_dispatcher, MultiTimerViewSubmenu);
}

// Submenu callbacks
static void submenu_callback(void* context, uint32_t index) {
    MultiTimerApp* app = context;
    if(!app) return;

    if(index < sizeof(preset_times) / sizeof(preset_times[0])) {
        // Preset timer selected - create timer directly
        int slot = find_free_timer_slot(app);
        if(slot >= 0) {
            TimerData* timer = &app->timer_storage.timers[slot];
            timer->active = true;
            timer->start_timestamp = furi_hal_rtc_get_timestamp();
            timer->duration_seconds = preset_times[index];
            timer->state = TimerStateRunning;
            snprintf(timer->name, sizeof(timer->name), "%s", preset_names[index]);

            app->timer_storage.count++;
            save_timer_data(app);

            app->selected_timer_index = slot;
            if(app->view_dispatcher) {
                view_dispatcher_switch_to_view(app->view_dispatcher, MultiTimerViewTimerRunning);
            }
        }
    } else if(index == sizeof(preset_times) / sizeof(preset_times[0])) {
        // Custom timer selected
        if(app->view_dispatcher) {
            view_dispatcher_switch_to_view(app->view_dispatcher, MultiTimerViewTimerSetup);
        }
    } else if(index == sizeof(preset_times) / sizeof(preset_times[0]) + 1) {
        // View active timers
        if(app->view_dispatcher) {
            view_dispatcher_switch_to_view(app->view_dispatcher, MultiTimerViewTimerList);
        }
    }
}

// View dispatcher callbacks
static bool multitimer_navigation_event_callback(void* context) {
    UNUSED(context);
    return true;
}

static bool multitimer_custom_event_callback(void* context, uint32_t event) {
    UNUSED(context);
    UNUSED(event);
    return false;
}

// App initialization
static MultiTimerApp* multitimer_app_alloc() {
    MultiTimerApp* app = malloc(sizeof(MultiTimerApp));
    if(!app) {
        return NULL;
    }

    // Initialize all pointers to NULL first
    memset(app, 0, sizeof(MultiTimerApp));

    app->gui = furi_record_open(RECORD_GUI);
    app->notifications = furi_record_open(RECORD_NOTIFICATION);
    app->storage = furi_record_open(RECORD_STORAGE);

    if(!app->gui || !app->notifications || !app->storage) {
        FURI_LOG_E(TAG, "Failed to open required records");
        multitimer_app_free(app);
        return NULL;
    }

    app->view_dispatcher = view_dispatcher_alloc();
    if(!app->view_dispatcher) {
        FURI_LOG_E(TAG, "Failed to allocate view dispatcher");
        multitimer_app_free(app);
        return NULL;
    }

    view_dispatcher_set_event_callback_context(app->view_dispatcher, app);
    view_dispatcher_set_navigation_event_callback(
        app->view_dispatcher, multitimer_navigation_event_callback);
    view_dispatcher_set_custom_event_callback(
        app->view_dispatcher, multitimer_custom_event_callback);
    view_dispatcher_attach_to_gui(app->view_dispatcher, app->gui, ViewDispatcherTypeFullscreen);

    // Initialize submenu
    app->submenu = submenu_alloc();
    if(!app->submenu) {
        FURI_LOG_E(TAG, "Failed to allocate submenu");
        multitimer_app_free(app);
        return NULL;
    }

    // Add preset options
    for(size_t i = 0; i < sizeof(preset_times) / sizeof(preset_times[0]); i++) {
        submenu_add_item(app->submenu, preset_names[i], i, submenu_callback, app);
    }
    submenu_add_item(
        app->submenu,
        "Custom Timer",
        sizeof(preset_times) / sizeof(preset_times[0]),
        submenu_callback,
        app);
    submenu_add_item(
        app->submenu,
        "View Active Timers",
        sizeof(preset_times) / sizeof(preset_times[0]) + 1,
        submenu_callback,
        app);

    view_dispatcher_add_view(
        app->view_dispatcher, MultiTimerViewSubmenu, submenu_get_view(app->submenu));

    // Initialize timer setup view
    app->timer_setup_view = view_alloc();
    if(!app->timer_setup_view) {
        FURI_LOG_E(TAG, "Failed to allocate timer setup view");
        multitimer_app_free(app);
        return NULL;
    }
    view_set_context(app->timer_setup_view, app);
    view_set_draw_callback(app->timer_setup_view, timer_setup_draw_callback);
    view_set_input_callback(app->timer_setup_view, timer_setup_input_callback);
    view_dispatcher_add_view(
        app->view_dispatcher, MultiTimerViewTimerSetup, app->timer_setup_view);

    // Initialize timer running view
    app->timer_running_view = view_alloc();
    if(!app->timer_running_view) {
        FURI_LOG_E(TAG, "Failed to allocate timer running view");
        multitimer_app_free(app);
        return NULL;
    }
    view_set_context(app->timer_running_view, app);
    view_set_draw_callback(app->timer_running_view, timer_running_draw_callback);
    view_set_input_callback(app->timer_running_view, timer_running_input_callback);
    view_dispatcher_add_view(
        app->view_dispatcher, MultiTimerViewTimerRunning, app->timer_running_view);

    // Initialize timer list view
    app->timer_list_view = view_alloc();
    if(!app->timer_list_view) {
        FURI_LOG_E(TAG, "Failed to allocate timer list view");
        multitimer_app_free(app);
        return NULL;
    }
    view_set_context(app->timer_list_view, app);
    view_set_draw_callback(app->timer_list_view, timer_list_draw_callback);
    view_set_input_callback(app->timer_list_view, timer_list_input_callback);
    view_dispatcher_add_view(app->view_dispatcher, MultiTimerViewTimerList, app->timer_list_view);

    // Initialize welcome popup
    app->welcome_popup = popup_alloc();
    if(!app->welcome_popup) {
        FURI_LOG_E(TAG, "Failed to allocate welcome popup");
        multitimer_app_free(app);
        return NULL;
    }
    popup_set_context(app->welcome_popup, app);
    popup_set_callback(app->welcome_popup, welcome_popup_callback);
    popup_set_icon(app->welcome_popup, 40, 8, &I_dolphin_welcome_45x45);
    popup_set_header(app->welcome_popup, "Welcome!", 64, 60, AlignCenter, AlignTop);
    popup_set_text(
        app->welcome_popup,
        "Multi Timer App\nby Flipper Enthusiast",
        64,
        50,
        AlignCenter,
        AlignTop);
    popup_set_timeout(app->welcome_popup, 3000); // 3 seconds
    popup_enable_timeout(app->welcome_popup);
    view_dispatcher_add_view(
        app->view_dispatcher, MultiTimerViewWelcomePopup, popup_get_view(app->welcome_popup));

    // Initialize timer state
    app->state = TimerStateSetup;
    app->setup_hours = 0;
    app->setup_minutes = 5;
    app->setup_seconds = 0;
    app->setup_selection = 1; // Start with minutes selected
    app->selected_timer_index = -1;

    // Load existing timer data
    load_timer_data(app);

    // Create timer
    app->tick_timer = furi_timer_alloc(timer_tick_callback, FuriTimerTypePeriodic, app);
    if(!app->tick_timer) {
        FURI_LOG_E(TAG, "Failed to allocate tick timer");
        multitimer_app_free(app);
        return NULL;
    }

    return app;
}

static void multitimer_app_free(MultiTimerApp* app) {
    if(!app) return;

    // Stop and free timer first to prevent callbacks during cleanup
    if(app->tick_timer) {
        furi_timer_stop(app->tick_timer);
        furi_timer_free(app->tick_timer);
        app->tick_timer = NULL;
    }

    // Remove views from dispatcher before freeing them
    if(app->view_dispatcher) {
        if(app->submenu) {
            view_dispatcher_remove_view(app->view_dispatcher, MultiTimerViewSubmenu);
        }
        if(app->timer_setup_view) {
            view_dispatcher_remove_view(app->view_dispatcher, MultiTimerViewTimerSetup);
        }
        if(app->timer_running_view) {
            view_dispatcher_remove_view(app->view_dispatcher, MultiTimerViewTimerRunning);
        }
        if(app->timer_list_view) {
            view_dispatcher_remove_view(app->view_dispatcher, MultiTimerViewTimerList);
        }
        if(app->welcome_popup) {
            view_dispatcher_remove_view(app->view_dispatcher, MultiTimerViewWelcomePopup);
        }
    }

    // Free individual views
    if(app->submenu) {
        submenu_free(app->submenu);
        app->submenu = NULL;
    }
    if(app->timer_setup_view) {
        view_free(app->timer_setup_view);
        app->timer_setup_view = NULL;
    }
    if(app->timer_running_view) {
        view_free(app->timer_running_view);
        app->timer_running_view = NULL;
    }
    if(app->timer_list_view) {
        view_free(app->timer_list_view);
        app->timer_list_view = NULL;
    }
    if(app->welcome_popup) {
        popup_free(app->welcome_popup);
        app->welcome_popup = NULL;
    }

    // Free view dispatcher last
    if(app->view_dispatcher) {
        view_dispatcher_free(app->view_dispatcher);
        app->view_dispatcher = NULL;
    }

    // Close records
    if(app->storage) {
        furi_record_close(RECORD_STORAGE);
        app->storage = NULL;
    }
    if(app->notifications) {
        furi_record_close(RECORD_NOTIFICATION);
        app->notifications = NULL;
    }
    if(app->gui) {
        furi_record_close(RECORD_GUI);
        app->gui = NULL;
    }

    // Finally free the app structure itself
    free(app);
}

int32_t multitimer_app(void* p) {
    UNUSED(p);

    MultiTimerApp* app = multitimer_app_alloc();
    if(!app) {
        FURI_LOG_E(TAG, "Failed to allocate app");
        return -1;
    }

    // Start with welcome popup
    view_dispatcher_switch_to_view(app->view_dispatcher, MultiTimerViewWelcomePopup);

    // Start the timer for periodic updates
    furi_timer_start(app->tick_timer, 1000); // 1 second intervals

    // Run the app
    view_dispatcher_run(app->view_dispatcher);

    multitimer_app_free(app);
    return 0;
}
