#include "//ATMlib.h"

#include <furi.h>
#include <furi_hal.h>
#include <furi_hal_speaker.h>

#include <string.h>

#define //ATM_CH_COUNT 4

// ------------------------------ Note table ----------------------------------
static const uint16_t noteTable[64] = {
    0,
    262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,
    523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,
    1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976,
    2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,
    4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459, 7902,
    8372, 8870, 9397,
};

// ----------------------------- Song state -----------------------------------
static uint8_t trackCount = 0;
static uint8_t tickRate = 25;
static const uint16_t* trackList = NULL;
static const uint8_t* trackBase = NULL;

static uint8_t ChannelActiveMute = 0b11110000;

typedef struct {
    const uint8_t* ptr;
    uint8_t note;

    uint16_t stackPointer[7];
    uint8_t stackCounter[7];
    uint8_t stackTrack[7];
    uint8_t stackIndex;
    uint8_t repeatPoint;

    uint16_t delay;
    uint8_t counter;
    uint8_t track;

    uint16_t freq;
    uint8_t vol;

    int8_t volFreSlide;
    uint8_t volFreConfig;
    uint8_t volFreCount;

    uint8_t arpNotes;
    uint8_t arpTiming;
    uint8_t arpCount;

    uint8_t reConfig;
    uint8_t reCount;

    int8_t transConfig;

    uint8_t treviDepth;
    uint8_t treviConfig;
    uint8_t treviCount;

    int8_t glisConfig;
    uint8_t glisCount;

} atm_ch_t;

static atm_ch_t channel[//ATM_CH_COUNT];

static FuriTimer* atm_timer = NULL;
static bool atm_playing = false;
static float master_volume = 0.35f; // safe default

// ----------------------------- helpers --------------------------------------
static uint16_t read_vle(const uint8_t** pp) {
    uint16_t q = 0;
    uint8_t d;
    do {
        q <<= 7;
        d = *(*pp)++;
        q |= (uint16_t)(d & 0x7F);
    } while(d & 0x80);
    return q;
}

static inline const uint8_t* getTrackPointer(uint8_t track) {
    if(!trackBase || !trackList) return NULL;
    return trackBase + trackList[track];
}

static void speaker_apply(float freq, float vol) {
    if(vol <= 0.001f || freq <= 1.0f) {
        furi_hal_speaker_stop();
    } else {
        furi_hal_speaker_start(freq, vol);
    }
}

// mono output: loudest active non-muted among channels 0..2
static void output_update(void) {
    if(!atm_playing) return;

    int best = -1;
    int best_vol = -1;

    for(int n = 0; n < 3; n++) {
        if(ChannelActiveMute & (1u << n)) continue;             // muted
        if(!(ChannelActiveMute & (1u << (n + 4)))) continue;    // not active
        int v = (int)channel[n].vol;
        int f = (int)channel[n].freq;
        if(v > best_vol && v > 0 && f > 0) {
            best_vol = v;
            best = n;
        }
    }

    if(best < 0) {
        speaker_apply(0, 0);
        return;
    }

    float freq = (float)channel[best].freq;
    float vol = ((float)best_vol / 63.0f) * master_volume;
    if(vol < 0.0f) vol = 0.0f;
    if(vol > 1.0f) vol = 1.0f;
    speaker_apply(freq, vol);
}

// --------------------------- tracker engine ---------------------------------
static void atm_playroutine(void) {
    for(uint8_t n = 0; n < //ATM_CH_COUNT; n++) {
        atm_ch_t* ch = &channel[n];

        if(ch->reConfig) {
            if(ch->reCount >= (ch->reConfig & 0x03)) {
                uint8_t idx = (uint8_t)(ch->reConfig >> 2);
                if(idx > 63) idx = 63;
                ch->freq = noteTable[idx];
                ch->reCount = 0;
            } else ch->reCount++;
        }

        if(ch->glisConfig) {
            if(ch->glisCount >= (uint8_t)(ch->glisConfig & 0x7F)) {
                if(ch->glisConfig & 0x80) ch->note -= 1;
                else ch->note += 1;
                if(ch->note < 1) ch->note = 1;
                else if(ch->note > 63) ch->note = 63;
                ch->freq = noteTable[ch->note];
                ch->glisCount = 0;
            } else ch->glisCount++;
        }

        if(ch->volFreSlide) {
            if(!ch->volFreCount) {
                int16_t vf = (int16_t)((ch->volFreConfig & 0x40) ? ch->freq : ch->vol);
                vf += (int16_t)ch->volFreSlide;

                if(!(ch->volFreConfig & 0x80)) {
                    if(vf < 0) vf = 0;
                    else if(ch->volFreConfig & 0x40) {
                        if(vf > 9397) vf = 9397;
                    } else {
                        if(vf > 63) vf = 63;
                    }
                }
                if(ch->volFreConfig & 0x40) ch->freq = (uint16_t)vf;
                else ch->vol = (uint8_t)vf;
            }
            if(ch->volFreCount++ >= (ch->volFreConfig & 0x3F)) ch->volFreCount = 0;
        }

        if(ch->arpNotes && ch->note) {
            if((ch->arpCount & 0x1F) < (ch->arpTiming & 0x1F)) ch->arpCount++;
            else {
                if((ch->arpCount & 0xE0) == 0x00) ch->arpCount = 0x20;
                else if((ch->arpCount & 0xE0) == 0x20 && !(ch->arpTiming & 0x40) &&
                        (ch->arpNotes != 0xFF))
                    ch->arpCount = 0x40;
                else
                    ch->arpCount = 0x00;

                uint8_t arpNote = ch->note;
                if((ch->arpCount & 0xE0) != 0x00) {
                    if(ch->arpNotes == 0xFF) arpNote = 0;
                    else arpNote = (uint8_t)(arpNote + (ch->arpNotes >> 4));
                }
                if((ch->arpCount & 0xE0) == 0x40) arpNote = (uint8_t)(arpNote + (ch->arpNotes & 0x0F));

                int idx = (int)arpNote + (int)ch->transConfig;
                if(idx < 0) idx = 0;
                if(idx > 63) idx = 63;
                ch->freq = noteTable[idx];
            }
        }

        if(ch->treviDepth) {
            int16_t vt = (int16_t)((ch->treviConfig & 0x40) ? ch->freq : ch->vol);
            vt = (ch->treviCount & 0x80) ? (vt + ch->treviDepth) : (vt - ch->treviDepth);

            if(vt < 0) vt = 0;
            else if(ch->treviConfig & 0x40) {
                if(vt > 9397) vt = 9397;
            } else {
                if(vt > 63) vt = 63;
            }

            if(ch->treviConfig & 0x40) ch->freq = (uint16_t)vt;
            else ch->vol = (uint8_t)vt;

            if((ch->treviCount & 0x1F) < (ch->treviConfig & 0x1F)) ch->treviCount++;
            else {
                if(ch->treviCount & 0x80) ch->treviCount = 0;
                else ch->treviCount = 0x80;
            }
        }

        if(ch->delay) {
            if(ch->delay != 0xFFFF) ch->delay--;
        } else {
            do {
                if(!ch->ptr) {
                    ch->delay = 0xFFFF;
                    break;
                }

                uint8_t cmd = *ch->ptr++;

                if(cmd < 64) {
                    ch->note = cmd;
                    if(ch->note) {
                        int nn = (int)ch->note + (int)ch->transConfig;
                        if(nn < 1) nn = 1;
                        if(nn > 63) nn = 63;
                        ch->note = (uint8_t)nn;
                    }
                    ch->freq = noteTable[ch->note];
                    if(!ch->volFreConfig) ch->vol = ch->reCount;
                    if(ch->arpTiming & 0x20) ch->arpCount = 0;

                    // mark active
                    ChannelActiveMute |= (1u << (n + 4));

                } else if(cmd < 160) {
                    switch(cmd - 64) {
                    case 0:
                        ch->vol = *ch->ptr++;
                        ch->reCount = ch->vol;
                        break;
                    case 1:
                    case 4:
                        ch->volFreSlide = (int8_t)(*ch->ptr++);
                        ch->volFreConfig = ((cmd - 64) == 1) ? 0x00 : 0x40;
                        break;
                    case 2:
                    case 5:
                        ch->volFreSlide = (int8_t)(*ch->ptr++);
                        ch->volFreConfig = *ch->ptr++;
                        break;
                    case 3:
                    case 6:
                        ch->volFreSlide = 0;
                        break;
                    case 7:
                        ch->arpNotes = *ch->ptr++;
                        ch->arpTiming = *ch->ptr++;
                        break;
                    case 8:
                        ch->arpNotes = 0;
                        break;
                    case 9:
                        ch->reConfig = *ch->ptr++;
                        break;
                    case 10:
                        ch->reConfig = 0;
                        break;
                    case 11:
                        ch->transConfig += (int8_t)(*ch->ptr++);
                        break;
                    case 12:
                        ch->transConfig = (int8_t)(*ch->ptr++);
                        break;
                    case 13:
                        ch->transConfig = 0;
                        break;
                    case 14:
                    case 16:
                        ch->treviDepth = *ch->ptr++;
                        ch->treviConfig = *ch->ptr++;
                        ch->treviConfig |= ((cmd - 64) == 16) ? 0x40 : 0x00;
                        break;
                    case 15:
                    case 17:
                        ch->treviDepth = 0;
                        break;
                    case 18:
                        ch->glisConfig = (int8_t)(*ch->ptr++);
                        break;
                    case 19:
                        ch->glisConfig = 0;
                        break;
                    case 20:
                        ch->arpNotes = 0xFF;
                        ch->arpTiming = *ch->ptr++;
                        break;
                    case 21:
                        ch->arpNotes = 0;
                        break;
                    case 92:
                        tickRate = (uint8_t)(tickRate + *ch->ptr++);
                        if(tickRate < 1) tickRate = 1;
                        break;
                    case 93:
                        tickRate = *ch->ptr++;
                        if(tickRate < 1) tickRate = 1;
                        break;
                    case 94:
                        for(uint8_t i = 0; i < //ATM_CH_COUNT; i++) channel[i].repeatPoint = *ch->ptr++;
                        break;
                    case 95:
                        // stop channel: clear active bit
                        ChannelActiveMute &= (uint8_t)(~(1u << (n + 4)));
                        ch->vol = 0;
                        ch->delay = 0xFFFF;
                        break;
                    default:
                        break;
                    }

                } else if(cmd < 224) {
                    ch->delay = (uint16_t)(cmd - 159);
                } else if(cmd == 224) {
                    ch->delay = (uint16_t)(read_vle(&ch->ptr) + 65);
                } else if(cmd < 252) {
                    // reserved
                } else if(cmd == 252 || cmd == 253) {
                    uint8_t new_counter = (cmd == 252) ? 0 : *ch->ptr++;
                    uint8_t new_track = *ch->ptr++;

                    if(new_track != ch->track) {
                        if(ch->stackIndex < 7) {
                            ch->stackCounter[ch->stackIndex] = ch->counter;
                            ch->stackTrack[ch->stackIndex] = ch->track;
                            ch->stackPointer[ch->stackIndex] = (uint16_t)(ch->ptr - trackBase);
                            ch->stackIndex++;
                        }
                        ch->track = new_track;
                    }

                    ch->counter = new_counter;
                    ch->ptr = getTrackPointer(ch->track);

                } else if(cmd == 254) {
                    if(ch->counter > 0 || ch->stackIndex == 0) {
                        if(ch->counter) ch->counter--;
                        ch->ptr = getTrackPointer(ch->track);
                    } else {
                        if(ch->stackIndex == 0) {
                            ch->delay = 0xFFFF;
                        } else {
                            ch->stackIndex--;
                            ch->ptr = ch->stackPointer[ch->stackIndex] + trackBase;
                            ch->counter = ch->stackCounter[ch->stackIndex];
                            ch->track = ch->stackTrack[ch->stackIndex];
                        }
                    }
                } else if(cmd == 255) {
                    ch->ptr += read_vle(&ch->ptr);
                }

            } while(ch->delay == 0);

            if(ch->delay != 0xFFFF) ch->delay--;
        }

        // End-of-song handling: if all inactive
        if((ChannelActiveMute & 0xF0) == 0) {
            uint8_t repeatSong = 0;
            for(uint8_t j = 0; j < //ATM_CH_COUNT; j++)
                repeatSong = (uint8_t)(repeatSong + channel[j].repeatPoint);

            if(repeatSong) {
                for(uint8_t k = 0; k < //ATM_CH_COUNT; k++) {
                    channel[k].ptr = getTrackPointer(channel[k].repeatPoint);
                    channel[k].track = channel[k].repeatPoint;
                    channel[k].delay = 0;
                    ChannelActiveMute |= (1u << (k + 4));
                }
            } else {
                // stop playback
                atm_playing = false;
                speaker_apply(0, 0);
            }
        }
    }
}

// ----------------------------- timer ----------------------------------------
static void atm_tick_cb(void* ctx) {
    (void)ctx;
    if(!atm_playing) return;
    atm_playroutine();
    output_update();
}

// ----------------------------- core control ---------------------------------
static void atm_internal_stop(void) {
    atm_playing = false;

    if(atm_timer) {
        furi_timer_stop(atm_timer);
        furi_timer_free(atm_timer);
        atm_timer = NULL;
    }

    if(furi_hal_speaker_is_mine()) {
        furi_hal_speaker_stop();
        furi_hal_speaker_release();
    }

    memset(channel, 0, sizeof(channel));
    trackCount = 0;
    trackList = NULL;
    trackBase = NULL;
    ChannelActiveMute = 0b11110000;
}

static void atm_internal_play(const uint8_t* song) {
    if(!song) return;

    // stop previous if running
    if(atm_playing) atm_internal_stop();

    // init speaker mutex if app didn't call init explicitly
    static bool speaker_inited = false;
    if(!speaker_inited) {
        furi_hal_speaker_init();
        speaker_inited = true;
    }

    if(!furi_hal_speaker_acquire(200)) {
        return;
    }

    memset(channel, 0, sizeof(channel));
    ChannelActiveMute = 0b11110000;

    tickRate = 25;

    // Parse song container (same as your Arduino code)
    trackCount = *song++;
    trackList = (const uint16_t*)song;
    song += (uint32_t)trackCount * 2u;

    trackBase = song + 4;

    for(uint8_t n = 0; n < //ATM_CH_COUNT; n++) {
        uint8_t start_track = *song++;
        channel[n].ptr = getTrackPointer(start_track);
        channel[n].track = start_track;
        channel[n].delay = 0;
        ChannelActiveMute |= (1u << (n + 4)); // mark active
    }

    atm_timer = furi_timer_alloc(atm_tick_cb, FuriTimerTypePeriodic, NULL);
    if(!atm_timer) {
        furi_hal_speaker_release();
        return;
    }

    atm_playing = true;
    furi_timer_start(atm_timer, furi_ms_to_ticks(1000 / tickRate));
}

// ----------------------------- API facade -----------------------------------
static void //ATM_play_impl(const uint8_t* song) {
    atm_internal_play(song);
}

static void //ATM_stop_impl(void) {
    atm_internal_stop();
}

static void //ATM_playPause_impl(void) {
    if(!atm_timer) return;

    if(atm_playing) {
        atm_playing = false;
        furi_timer_stop(atm_timer);
        furi_hal_speaker_stop();
    } else {
        atm_playing = true;
        furi_timer_start(atm_timer, furi_ms_to_ticks(1000 / tickRate));
    }
}

static void //ATM_mute_impl(uint8_t ch) {
    if(ch < //ATM_CH_COUNT) ChannelActiveMute |= (1u << ch);
}

static void //ATM_unmute_impl(uint8_t ch) {
    if(ch < //ATM_CH_COUNT) ChannelActiveMute &= (uint8_t)(~(1u << ch));
}

static void //ATM_setvol_impl(float v) {
    if(v < 0.0f) v = 0.0f;
    if(v > 1.0f) v = 1.0f;
    master_volume = v;
}

// Global object expected by your code: //ATM.play(), //ATM.stop(), ...
//ATMsynth //ATM = {
    .play = //ATM_play_impl,
    .stop = //ATM_stop_impl,
    .playPause = //ATM_playPause_impl,
    .muteChannel = //ATM_mute_impl,
    .unMuteChannel = //ATM_unmute_impl,
    .setVolume = //ATM_setvol_impl,
};
