#include <furi.h>

#include "iconedit.h"

#include <dialogs/dialogs.h>
#include <flipper_format/flipper_format.h>
#include <gui/canvas.h>
#include <gui/view_holder.h>
#include <input/input.h>
#include <notification/notification.h>
#include <notification/notification_messages.h>
#include <toolbox/api_lock.h>

/* generated by fbt from .png files in images folder */
#include <iconedit_icons.h>

#include "icon.h"
#include "panels/panels.h"

#define ICONEDIT_SETTINGS_FILENAME     ".iconedit.conf"
#define ICONEDIT_SETTINGS_PATH         APP_DATA_PATH(ICONEDIT_SETTINGS_FILENAME)
#define ICONEDIT_SETTINGS_FILE_TYPE    "IconEdit Settings File"
#define ICONEDIT_SETTINGS_FILE_VERSION 1

#define ICONEDIT_SETTING_CANVAS_SCALE  "Canvas Scale"
#define ICONEDIT_SETTING_CURSOR_GUIDES "Cursor Guides"

// We don't just draw the current tab or panel. Since some panels can overlay
// others (like the modal panels), we need to draw them last
void iconedit_draw_callback(Canvas* canvas, void* context) {
    IconEdit* app = context;
    canvas_clear(canvas);

    // for now, playback is fullscreen-ish
    if(app->panel == Panel_Playback) {
        playback_draw(canvas, app);
        return;
    }

    tabbar_draw(canvas, app);

    switch(tabbar_get_selected_tab()) {
    case TabFile:
        file_draw(canvas, app);
        break;
    case TabTools:
        tools_draw(canvas, app);
        break;
    case TabSettings:
        settings_draw(canvas, app);
        break;
    case TabHelp:
        help_draw(canvas, app);
        break;
    case TabAbout:
        about_draw(canvas, app);
        break;
    default:
        break;
    }

    Tab selected_tab = tabbar_get_selected_tab();
    if(selected_tab == TabFile || selected_tab == TabTools) {
        canvas_draw(canvas, app);
    }

    // now draw modal panels
    switch(app->panel) {
    case Panel_New:
        new_icon_draw(canvas, app);
        break;
    case Panel_SaveAs:
        save_as_draw(canvas, app);
        break;
    case Panel_FPS:
        fps_draw(canvas, app);
        break;
    case Panel_Playback:
        playback_draw(canvas, app);
        break;
    case Panel_SendUSB:
        send_usb_draw(canvas, app);
        break;
    case Panel_Dialog:
        dialog_draw(canvas, app);
        break;
    case Panel_SendAs:
        send_as_draw(canvas, app);
        break;
    default:
        break;
    }
}

void iconedit_user_exit(void* context, DialogButton button) {
    IconEdit* app = context;
    app->panel = Panel_TabBar;
    if(button == DialogBtn_OK) {
        app->running = false;
    }
}

bool iconedit_input_process_event(InputEvent* event, void* context) {
    furi_assert(event);
    IconEdit* app = context;
    bool consumed = false;

    switch(app->panel) {
    case Panel_TabBar:
        consumed = tabbar_input(event, context);
        if(!consumed) {
            if(app->dirty) {
                app->panel = Panel_Dialog;
                dialog_setup("Unsaved changes, exit?", Dialog_OK_CANCEL, iconedit_user_exit, app);
            } else {
                app->running = false;
            }
        }
        break;
    case Panel_File:
        consumed = file_input(event, context);
        break;
    case Panel_Tools:
        consumed = tools_input(event, context);
        break;
    case Panel_Playback:
        consumed = playback_input(event, context);
        break;
    case Panel_Settings:
        consumed = settings_input(event, context);
        canvas_set_scale(app->settings.canvas_scale);
        break;
    case Panel_About:
        consumed = about_input(event, context);
        break;
    case Panel_Canvas:
        consumed = canvas_input(event, context);
        break;
    case Panel_New:
        consumed = new_icon_input(event, context);
        break;
    case Panel_SaveAs:
        consumed = save_as_input(event, context);
        break;
    case Panel_FPS:
        consumed = fps_input(event, context);
        break;
    case Panel_SendUSB:
        consumed = send_usb_input(event, context);
        break;
    case Panel_Dialog:
        consumed = dialog_input(event, context);
        break;
    case Panel_SendAs:
        consumed = send_as_input(event, context);
        break;
    case Panel_Help:
        consumed = help_input(event, context);
        break;

    default:
        break;
    }

    return consumed;
}

void iconedit_input_callback(InputEvent* input_event, void* context) {
    FuriMessageQueue* event_queue = context;
    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

IconEdit* iconedit_app_alloc() {
    IconEdit* app = malloc(sizeof(IconEdit));
    app->mutex = furi_mutex_alloc(FuriMutexTypeNormal);

    app->icon = ie_icon_alloc(true);

    app->panel = Panel_Tools;

    app->storage = furi_record_open(RECORD_STORAGE);
    app->temp_str = furi_string_alloc();

    app->running = true;
    app->dirty = false;

    return app;
}

void iconedit_app_free(IconEdit* app) {
    dialog_free_dialog();

    ie_icon_free(app->icon);
    canvas_free_canvas();

    furi_record_close(RECORD_STORAGE);
    furi_string_free(app->temp_str);
    furi_mutex_free(app->mutex);
    free(app);
}

void iconedit_load_settings(IconEdit* app) {
    FlipperFormat* fff_settings = flipper_format_file_alloc(app->storage);
    FuriString* tmp_str = furi_string_alloc();
    uint32_t tmp_data32 = 0;

    IESettings* settings = &app->settings;
    // init settings to default values
    settings->canvas_scale = SETTING_SCALE_AUTO;
    settings->draw_cursor_guides = true;

    do {
        if(!flipper_format_file_open_existing(fff_settings, ICONEDIT_SETTINGS_PATH)) {
            FURI_LOG_I(TAG, "SETTINGS: File not found, using defaults");
            break;
        }
        if(!flipper_format_read_header(fff_settings, tmp_str, &tmp_data32)) {
            FURI_LOG_E(TAG, "SETTINGS: Missing or incorrect header");
            break;
        }
        if(!strcmp(furi_string_get_cstr(tmp_str), ICONEDIT_SETTINGS_FILE_TYPE) &&
           (tmp_data32 == ICONEDIT_SETTINGS_FILE_VERSION)) {
        } else {
            FURI_LOG_E(TAG, "SETTINGS: Type or version mismatch");
            break;
        }
        if(flipper_format_read_uint32(
               fff_settings, ICONEDIT_SETTING_CANVAS_SCALE, &tmp_data32, 1)) {
            settings->canvas_scale = tmp_data32;
        }
        if(flipper_format_read_uint32(
               fff_settings, ICONEDIT_SETTING_CURSOR_GUIDES, &tmp_data32, 1)) {
            settings->draw_cursor_guides = (tmp_data32 == 0) ? false : true;
        }
    } while(false);

    furi_string_free(tmp_str);
    flipper_format_free(fff_settings);
}

void iconedit_save_settings(IconEdit* app) {
    FlipperFormat* fff_settings = flipper_format_file_alloc(app->storage);
    uint32_t tmp_data32 = 0;
    IESettings* settings = &app->settings;

    FURI_LOG_I(TAG, "SETTINGS: Saving settings");
    do {
        if(!flipper_format_file_open_always(fff_settings, ICONEDIT_SETTINGS_PATH)) {
            FURI_LOG_E(TAG, "SETTINGS: Unable to open file for save!");
            break;
        }
        if(!flipper_format_write_header_cstr(
               fff_settings, ICONEDIT_SETTINGS_FILE_TYPE, ICONEDIT_SETTINGS_FILE_VERSION)) {
            FURI_LOG_E(TAG, "SETTINGS: Failed writing file type and version");
            break;
        }
        // now write out our settings data
        tmp_data32 = settings->canvas_scale;
        if(!flipper_format_write_uint32(
               fff_settings, ICONEDIT_SETTING_CANVAS_SCALE, &tmp_data32, 1)) {
            FURI_LOG_E(TAG, "SETTINGS: Failed to write '" ICONEDIT_SETTING_CANVAS_SCALE "'");
            break;
        }
        tmp_data32 = settings->draw_cursor_guides ? 1 : 0;
        if(!flipper_format_write_uint32(
               fff_settings, ICONEDIT_SETTING_CURSOR_GUIDES, &tmp_data32, 1)) {
            FURI_LOG_E(TAG, "SETTINGS: Failed to write '" ICONEDIT_SETTING_CURSOR_GUIDES "'");
            break;
        }
    } while(false);

    flipper_format_file_close(fff_settings);
    flipper_format_free(fff_settings);
}

// Why does the callback need the IEIconAnimation* ptr?? the context is the most important thing
void iconedit_playback_animation_callback(IEIconAnimation* anim, void* context) {
    UNUSED(anim);
    ViewPort* view_port = context;
    view_port_update(view_port);
}

// called by panels when they need a re-draw
void iconedit_viewport_update_callback(void* context) {
    ViewPort* view_port = context;
    view_port_update(view_port);
}

int32_t iconedit_app(void* p) {
    UNUSED(p);
    FURI_LOG_I(TAG, "IconEdit starting");
    IconEdit* app = iconedit_app_alloc();

    iconedit_load_settings(app);
    canvas_initialize(app->icon, app->settings.canvas_scale);

    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));
    ViewPort* view_port = view_port_alloc();
    view_port_set_orientation(view_port, ViewPortOrientationHorizontal);
    view_port_draw_callback_set(view_port, iconedit_draw_callback, app);
    view_port_input_callback_set(view_port, iconedit_input_callback, event_queue);

    app->notify = furi_record_open(RECORD_NOTIFICATION);
    notification_message(app->notify, &sequence_display_backlight_on);

    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    playback_set_update_callback(iconedit_playback_animation_callback, view_port);
    send_usb_set_update_callback(iconedit_viewport_update_callback, view_port);

    FURI_LOG_W(
        TAG,
        "Icon created: %d x %d with name %s",
        app->icon->width,
        app->icon->height,
        furi_string_get_cstr(app->icon->name));
    FURI_LOG_I(TAG, "starting event loop");
    InputEvent event;
    while(app->running) {
        FuriStatus event_status = furi_message_queue_get(event_queue, &event, 1000);
        furi_mutex_acquire(app->mutex, FuriWaitForever);
        if(event_status == FuriStatusOk) {
            iconedit_input_process_event(&event, app);
        }
        furi_mutex_release(app->mutex);
        view_port_update(view_port);
    }

    notification_message(app->notify, &sequence_reset_display);
    furi_record_close(RECORD_NOTIFICATION);
    FURI_LOG_I(TAG, "App no longer running - cleanup");

    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    furi_record_close(RECORD_GUI);
    view_port_free(view_port);
    furi_message_queue_free(event_queue);

    iconedit_app_free(app);

    FURI_LOG_I(TAG, "IconEdit exiting");
    return 0;
}
