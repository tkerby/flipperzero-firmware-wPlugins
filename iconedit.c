#include <furi.h>

#include "iconedit.h"

#include <gui/canvas.h>
#include <gui/view_holder.h>
#include <input/input.h>
#include <notification/notification.h>
#include <notification/notification_messages.h>
#include <dialogs/dialogs.h>
#include <toolbox/api_lock.h>

/* generated by fbt from .png files in images folder */
#include <iconedit_icons.h>

#include "icon.h"
#include "panels/panels.h"

// We don't just draw the current tab or panel. Since some panels can overlay
// others (like the modal panels), we need to draw them last
void iconedit_draw_callback(Canvas* canvas, void* context) {
    IconEdit* app = context;
    // IEIcon* icon = app->icon;

    // FURI_LOG_I("Editor", "draw_callback");
    canvas_clear(canvas);

    // for now, playback is fullscreen-ish
    if(app->panel == Panel_Playback) {
        playback_draw(canvas, app);
        return;
    }

    tabbar_draw(canvas, app);

    switch(tabbar_get_selected_tab()) {
    case TabFile:
        file_draw(canvas, app);
        break;
    case TabTools:
        tools_draw(canvas, app);
        break;
    // case TabSettings:
    //     settings_draw(canvas, app);
    //     break;
    case TabHelp:
        help_draw(canvas, app);
        break;
    case TabAbout:
        about_draw(canvas, app);
        break;
    default:
        break;
    }

    Tab selected_tab = tabbar_get_selected_tab();
    if(selected_tab != TabHelp && selected_tab != TabAbout) {
        canvas_draw(canvas, app);
    }

    // now draw modal panels
    switch(app->panel) {
    case Panel_New:
        new_icon_draw(canvas, app);
        break;
    case Panel_SaveAs:
        save_as_draw(canvas, app);
        break;
    case Panel_FPS:
        fps_draw(canvas, app);
        break;
    case Panel_Playback:
        playback_draw(canvas, app);
        break;
    case Panel_SendUSB:
        send_usb_draw(canvas, app);
        break;
    case Panel_Dialog:
        dialog_draw(canvas, app);
        break;
    case Panel_SendAs:
        send_as_draw(canvas, app);
        break;
    default:
        break;
    }
}

void iconedit_user_exit(void* context, DialogButton button) {
    IconEdit* app = context;
    app->panel = Panel_TabBar;
    if(button == DialogBtn_OK) {
        app->running = false;
    }
}

bool iconedit_input_process_event(InputEvent* event, void* context) {
    furi_assert(event);
    IconEdit* app = context;
    FURI_LOG_I("Editor", "view_input_callback: %d, panel: %d", event->type, app->panel);

    bool consumed = false;

    switch(app->panel) {
    case Panel_TabBar:
        consumed = tabbar_input(event, context);
        if(!consumed) {
            if(app->dirty) {
                app->panel = Panel_Dialog;
                dialog_setup("Unsaved changes, exit?", Dialog_OK_CANCEL, iconedit_user_exit, app);
            } else {
                app->running = false;
            }
        }
        break;
    case Panel_File:
        consumed = file_input(event, context);
        break;
    case Panel_Tools:
        consumed = tools_input(event, context);
        break;
    case Panel_Playback:
        consumed = playback_input(event, context);
        break;
    // case Panel_Settings:
    //     consumed = settings_input(event, context);
    //     break;
    case Panel_About:
        consumed = about_input(event, context);
        break;
    case Panel_Canvas:
        consumed = canvas_input(event, context);
        break;
    case Panel_New:
        consumed = new_icon_input(event, context);
        break;
    case Panel_SaveAs:
        consumed = save_as_input(event, context);
        break;
    case Panel_FPS:
        consumed = fps_input(event, context);
        break;
    case Panel_SendUSB:
        consumed = send_usb_input(event, context);
        break;
    case Panel_Dialog:
        consumed = dialog_input(event, context);
        break;
    case Panel_SendAs:
        consumed = send_as_input(event, context);
        break;
    case Panel_Help:
        consumed = help_input(event, context);
        break;

    default:
        break;
    }

    return consumed;
}

// void tool_selected_callback(EditorTool tool, void* context) {
//     IconEdit* app = context;
//     canvas_set_selected_tool(tool);
// }

void iconedit_input_callback(InputEvent* input_event, void* context) {
    FuriMessageQueue* event_queue = context;
    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

IconEdit* iconedit_app_alloc() {
    IconEdit* app = malloc(sizeof(IconEdit));
    FURI_LOG_I(TAG, "app_alloc - impl");
    app->mutex = furi_mutex_alloc(FuriMutexTypeNormal);

    app->icon = ie_icon_alloc(true);
    FURI_LOG_I(TAG, "icon_alloc done");

    app->panel = Panel_Tools;

    app->storage = furi_record_open(RECORD_STORAGE);
    app->temp_str = furi_string_alloc();

    // panels setup
    // tools_set_callback(tool_selected_callback);
    canvas_alloc_canvas(app->icon->width, app->icon->height);

    app->running = true;
    app->dirty = false;

    return app;
}

void iconedit_app_free(IconEdit* app) {
    FURI_LOG_W(TAG, "_free");

    dialog_free_dialog();

    ie_icon_free(app->icon);
    canvas_free_canvas();

    furi_record_close(RECORD_STORAGE);

    furi_string_free(app->temp_str);

    furi_mutex_free(app->mutex);

    FURI_LOG_W(TAG, "_free");

    free(app);
}

// Why does the callback need the IEIconAnimation* ptr?? the context is the most important thing
void iconedit_playback_animation_callback(IEIconAnimation* anim, void* context) {
    UNUSED(anim);
    ViewPort* view_port = context;
    view_port_update(view_port);
}

// called by panels when they need a re-draw
void iconedit_viewport_update_callback(void* context) {
    ViewPort* view_port = context;
    view_port_update(view_port);
}

int32_t iconedit_app(void* p) {
    UNUSED(p);
    FURI_LOG_I(TAG, "iconedit_app");
    IconEdit* app = iconedit_app_alloc();
    FURI_LOG_I(TAG, "app_alloc");

    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));
    ViewPort* view_port = view_port_alloc();
    view_port_set_orientation(view_port, ViewPortOrientationHorizontal);
    view_port_draw_callback_set(view_port, iconedit_draw_callback, app);
    view_port_input_callback_set(view_port, iconedit_input_callback, event_queue);

    FURI_LOG_I(TAG, "view_port created");
    app->notify = furi_record_open(RECORD_NOTIFICATION);
    notification_message(app->notify, &sequence_display_backlight_on);

    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    playback_set_update_callback(iconedit_playback_animation_callback, view_port);
    send_usb_set_update_callback(iconedit_viewport_update_callback, view_port);

    FURI_LOG_W(
        TAG,
        "Icon created: %d x %d with name %s",
        app->icon->width,
        app->icon->height,
        furi_string_get_cstr(app->icon->name));
    FURI_LOG_I(TAG, "starting event loop");
    InputEvent event;
    while(app->running) {
        FuriStatus event_status = furi_message_queue_get(event_queue, &event, 1000);
        furi_mutex_acquire(app->mutex, FuriWaitForever);
        if(event_status == FuriStatusOk) {
            iconedit_input_process_event(&event, app);
        }
        view_port_update(view_port);
        furi_mutex_release(app->mutex);
    }

    notification_message(app->notify, &sequence_display_backlight_enforce_auto);
    furi_record_close(RECORD_NOTIFICATION);
    FURI_LOG_I(TAG, "App no longer running - cleanup");

    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    furi_record_close(RECORD_GUI);
    view_port_free(view_port);
    furi_message_queue_free(event_queue);

    iconedit_app_free(app);

    FURI_LOG_W(TAG, "Exiting");
    return 0;
}
