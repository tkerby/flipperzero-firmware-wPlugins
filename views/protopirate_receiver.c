// views/protopirate_receiver.c
#include "protopirate_receiver.h"
#include "../protopirate_app_i.h"
#include <input/input.h>
#include <gui/elements.h>
#include <furi.h>
#include <math.h>

#define FRAME_HEIGHT 12
#define MAX_LEN_PX   112
#define MENU_ITEMS   4u
#define UNLOCK_CNT   3

typedef struct {
    FuriString* item_str;
    uint8_t type;
} ProtoPirateReceiverMenuItem;

ARRAY_DEF(ProtoPirateReceiverMenuItemArray, ProtoPirateReceiverMenuItem, M_POD_OPLIST)

struct ProtoPirateReceiver {
    View* view;
    ProtoPirateReceiverCallback callback;
    void* context;
};

typedef struct {
    ProtoPirateReceiverMenuItemArray_t history_item_arr;
    uint8_t list_offset;
    uint8_t history_item;
    float rssi;
    FuriString* frequency_str;
    FuriString* preset_str;
    FuriString* history_stat_str;
    bool external_radio;
    ProtoPirateLock lock;
    uint8_t lock_count;
    uint8_t animation_frame;
} ProtoPirateReceiverModel;

void protopirate_view_receiver_set_rssi(ProtoPirateReceiver* receiver, float rssi) {
    furi_assert(receiver);
    with_view_model(
        receiver->view, ProtoPirateReceiverModel * model, { model->rssi = rssi; }, true);
}

void protopirate_view_receiver_set_lock(ProtoPirateReceiver* receiver, ProtoPirateLock lock) {
    furi_assert(receiver);
    with_view_model(
        receiver->view, ProtoPirateReceiverModel * model, { model->lock = lock; }, true);
}

void protopirate_view_receiver_set_callback(
    ProtoPirateReceiver* receiver,
    ProtoPirateReceiverCallback callback,
    void* context) {
    furi_assert(receiver);
    receiver->callback = callback;
    receiver->context = context;
}

static void protopirate_view_receiver_update_offset(ProtoPirateReceiver* receiver) {
    furi_assert(receiver);
    with_view_model(
        receiver->view,
        ProtoPirateReceiverModel * model,
        {
            size_t history_item = model->history_item;
            size_t list_offset = model->list_offset;
            size_t item_count = ProtoPirateReceiverMenuItemArray_size(model->history_item_arr);

            if(history_item < list_offset) {
                model->list_offset = history_item;
            } else if(history_item >= (list_offset + MENU_ITEMS)) {
                model->list_offset = history_item - (MENU_ITEMS - 1);
            }

            if(item_count < MENU_ITEMS) {
                model->list_offset = 0;
            } else if(model->list_offset > (item_count - MENU_ITEMS)) {
                model->list_offset = item_count - MENU_ITEMS;
            }
        },
        true);
}

void protopirate_view_receiver_add_item_to_menu(
    ProtoPirateReceiver* receiver,
    const char* name,
    uint8_t type) {
    furi_assert(receiver);
    with_view_model(
        receiver->view,
        ProtoPirateReceiverModel * model,
        {
            ProtoPirateReceiverMenuItem* item_menu =
                ProtoPirateReceiverMenuItemArray_push_raw(model->history_item_arr);
            item_menu->item_str = furi_string_alloc_set(name);
            item_menu->type = type;
        },
        true);
    protopirate_view_receiver_update_offset(receiver);
}

void protopirate_view_receiver_add_data_statusbar(
    ProtoPirateReceiver* receiver,
    const char* frequency_str,
    const char* preset_str,
    const char* history_stat_str,
    bool external_radio) {
    furi_assert(receiver);
    with_view_model(
        receiver->view,
        ProtoPirateReceiverModel * model,
        {
            furi_string_set_str(model->frequency_str, frequency_str);
            furi_string_set_str(model->preset_str, preset_str);
            furi_string_set_str(model->history_stat_str, history_stat_str);
            model->external_radio = external_radio;
        },
        true);
}

static void protopirate_view_receiver_draw_frame(Canvas* canvas, uint16_t idx, bool scrollbar) {
    canvas_set_color(canvas, ColorBlack);
    canvas_draw_box(canvas, 0, 0 + idx * FRAME_HEIGHT, scrollbar ? 122 : 127, FRAME_HEIGHT);

    canvas_set_color(canvas, ColorWhite);
    canvas_draw_dot(canvas, 0, 0 + idx * FRAME_HEIGHT);
    canvas_draw_dot(canvas, 1, 0 + idx * FRAME_HEIGHT);
    canvas_draw_dot(canvas, 0, (0 + idx * FRAME_HEIGHT) + 1);

    canvas_draw_dot(canvas, 0, (0 + idx * FRAME_HEIGHT) + 11);
    canvas_draw_dot(canvas, scrollbar ? 121 : 126, 0 + idx * FRAME_HEIGHT);
    canvas_draw_dot(canvas, scrollbar ? 121 : 126, (0 + idx * FRAME_HEIGHT) + 11);
}

void protopirate_view_receiver_draw(Canvas* canvas, ProtoPirateReceiverModel* model) {
    canvas_clear(canvas);
    canvas_set_color(canvas, ColorBlack);
    canvas_set_font(canvas, FontSecondary);

    // Increment animation frame
    model->animation_frame = (model->animation_frame + 1) % 96;

    size_t item_count = ProtoPirateReceiverMenuItemArray_size(model->history_item_arr);
    bool scrollbar = item_count > MENU_ITEMS;

    FuriString* str_buff;
    str_buff = furi_string_alloc();

    if(item_count > 0) {
        // Draw received items list
        size_t shift_position = model->list_offset;

        for(size_t i = 0; i < MIN(item_count, MENU_ITEMS); i++) {
            size_t idx = shift_position + i;
            ProtoPirateReceiverMenuItem* item =
                ProtoPirateReceiverMenuItemArray_get(model->history_item_arr, idx);

            furi_string_set(str_buff, item->item_str);
            elements_string_fit_width(canvas, str_buff, scrollbar ? MAX_LEN_PX - 6 : MAX_LEN_PX);

            if(model->history_item == idx) {
                protopirate_view_receiver_draw_frame(canvas, i, scrollbar);
            } else {
                canvas_set_color(canvas, ColorBlack);
            }

            canvas_draw_str(canvas, 4, 9 + (i * FRAME_HEIGHT), furi_string_get_cstr(str_buff));
        }

        if(scrollbar) {
            elements_scrollbar_pos(canvas, 128, 0, 49, shift_position, item_count);
        }
    } else {
        // Cool animated radar with expanding dots
        int center_x = 64;
        int center_y = 22;
        
        // Three waves of expanding circles with different speeds
        for(int wave = 0; wave < 3; wave++) {
            // Calculate radius for this wave with offset
            int base_radius = ((model->animation_frame + wave * 32) % 96) / 3;
            
            if(base_radius < 28) {
                // Calculate fade based on distance from center
                int dot_density = 24 - (base_radius / 2);
                
                // Draw circle with dots
                for(int angle = 0; angle < 360; angle += (360 / dot_density)) {
                    float rad = (angle + wave * 15) * 3.14159 / 180.0;
                    int x = center_x + base_radius * cosf(rad);
                    int y = center_y + base_radius * sinf(rad);
                    
                    // Only draw if within bounds and create fade effect
                    if(x > 0 && x < 128 && y > 0 && y < 48) {
                        // Dots get smaller/fade as they expand
                        if(base_radius < 10) {
                            canvas_draw_dot(canvas, x, y);
                            // Double dot for inner circles for brightness
                            if(base_radius < 5) {
                                canvas_draw_dot(canvas, x+1, y);
                            }
                        } else if(base_radius < 20) {
                            // Skip some dots for fade effect
                            if(angle % 30 == 0) {
                                canvas_draw_dot(canvas, x, y);
                            }
                        } else {
                            // Very sparse dots at edge
                            if(angle % 60 == 0) {
                                canvas_draw_dot(canvas, x, y);
                            }
                        }
                    }
                }
            }
        }
        
        // Static guide circles (very faint)
        for(int angle = 0; angle < 360; angle += 45) {
            float rad = angle * 3.14159 / 180.0;
            canvas_draw_dot(canvas, center_x + 15 * cosf(rad), center_y + 15 * sinf(rad));
        }
        
        // Rotating sweep line with glow effect
        float sweep_angle = (model->animation_frame * 3.75) * 3.14159 / 180.0;
        
        // Main sweep line
        int sweep_x = center_x + 22 * cosf(sweep_angle);
        int sweep_y = center_y + 22 * sinf(sweep_angle);
        canvas_draw_line(canvas, center_x, center_y, sweep_x, sweep_y);
        
        // Sweep "glow" - additional lines at slight offsets
        float glow_angle1 = sweep_angle - 0.05;
        float glow_angle2 = sweep_angle + 0.05;
        canvas_draw_line(canvas, center_x, center_y, 
                         center_x + 20 * cosf(glow_angle1), 
                         center_y + 20 * sinf(glow_angle1));
        canvas_draw_line(canvas, center_x, center_y,
                         center_x + 20 * cosf(glow_angle2),
                         center_y + 20 * sinf(glow_angle2));
        
        // Sweep trail (fading dots)
        for(int i = 1; i <= 12; i++) {
            float trail_angle = sweep_angle - (i * 0.15);
            int trail_radius = 22 - i;
            if(trail_radius > 0) {
                int trail_x = center_x + trail_radius * cosf(trail_angle);
                int trail_y = center_y + trail_radius * sinf(trail_angle);
                // Only draw every other dot in trail for fade effect
                if(i % 2 == 0 || i < 4) {
                    canvas_draw_dot(canvas, trail_x, trail_y);
                }
            }
        }
        
        // Pulsing center
        int pulse = (model->animation_frame % 32);
        if(pulse < 16) {
            canvas_draw_disc(canvas, center_x, center_y, 2);
        } else {
            canvas_draw_circle(canvas, center_x, center_y, 2);
        }
        if(pulse < 8 || (pulse > 16 && pulse < 24)) {
            canvas_draw_dot(canvas, center_x, center_y);
        }
        
        // Left-aligned config hint
        canvas_set_font(canvas, FontSecondary);
        canvas_draw_str(canvas, 2, 45, "< Config");
    }

    furi_string_free(str_buff);

    // Status bar separator
    canvas_set_color(canvas, ColorBlack);
    canvas_draw_line(canvas, 0, 48, 127, 48);

    // Draw status bar
    canvas_set_font(canvas, FontSecondary);
    
    // Activity indicator - pulsing when receiving
    if(model->rssi > -90) {
        int pulse = model->animation_frame % 16;
        if(pulse < 8) {
            canvas_draw_disc(canvas, 2, 54, 1);
        }
    }
    
    // Frequency
    canvas_draw_str(canvas, 5, 58, furi_string_get_cstr(model->frequency_str));
    
    // Preset
    canvas_draw_str(canvas, 44, 58, furi_string_get_cstr(model->preset_str));
    
    // History counter
    canvas_draw_str_aligned(
        canvas, 108, 58, AlignCenter, AlignBottom, furi_string_get_cstr(model->history_stat_str));

    // Draw RSSI indicator with animation
    uint8_t x = 70;
    uint8_t y = 51;
    float rssi = model->rssi;

    if(rssi >= -80.0f) {
        canvas_draw_box(canvas, x, y + 5, 3, 2);
    }
    if(rssi >= -70.0f) {
        canvas_draw_box(canvas, x + 4, y + 3, 3, 4);
    }
    if(rssi >= -60.0f) {
        canvas_draw_box(canvas, x + 8, y + 1, 3, 6);
        // Pulse effect for strong signal
        if(model->animation_frame % 24 < 12) {
            canvas_draw_frame(canvas, x + 7, y, 5, 8);
        }
    }

    // External radio indicator
    if(model->external_radio) {
        canvas_draw_str(canvas, 116, 58, "E");
    }

    // Lock indicator
    if(model->lock == ProtoPirateLockOn) {
        canvas_draw_str(canvas, 122, 58, "L");
    }
}

bool protopirate_view_receiver_input(InputEvent* event, void* context) {
    furi_assert(context);
    ProtoPirateReceiver* receiver = context;

    bool consumed = false;

    ProtoPirateLock lock;
    with_view_model(
        receiver->view, ProtoPirateReceiverModel * model, { lock = model->lock; }, false);

    if(lock == ProtoPirateLockOn) {
        with_view_model(
            receiver->view,
            ProtoPirateReceiverModel * model,
            {
                if(event->type == InputTypeShort && event->key == InputKeyBack) {
                    model->lock_count++;
                    if(model->lock_count >= UNLOCK_CNT) {
                        model->lock = ProtoPirateLockOff;
                        model->lock_count = 0;
                        if(receiver->callback) {
                            receiver->callback(
                                ProtoPirateCustomEventViewReceiverUnlock, receiver->context);
                        }
                    }
                } else {
                    model->lock_count = 0;
                }
            },
            true);
        consumed = true;
    } else if(event->type == InputTypeShort) {
        switch(event->key) {
        case InputKeyUp:
            with_view_model(
                receiver->view,
                ProtoPirateReceiverModel * model,
                {
                    if(model->history_item > 0) {
                        model->history_item--;
                    }
                },
                true);
            protopirate_view_receiver_update_offset(receiver);
            consumed = true;
            break;
        case InputKeyDown:
            with_view_model(
                receiver->view,
                ProtoPirateReceiverModel * model,
                {
                    size_t item_count =
                        ProtoPirateReceiverMenuItemArray_size(model->history_item_arr);
                    if(item_count > 0 && model->history_item < item_count - 1) {
                        model->history_item++;
                    }
                },
                true);
            protopirate_view_receiver_update_offset(receiver);
            consumed = true;
            break;
        case InputKeyLeft:
            if(receiver->callback) {
                receiver->callback(ProtoPirateCustomEventViewReceiverConfig, receiver->context);
            }
            consumed = true;
            break;
        case InputKeyRight:
            consumed = true;
            break;
        case InputKeyOk:
            with_view_model(
                receiver->view,
                ProtoPirateReceiverModel * model,
                {
                    size_t item_count =
                        ProtoPirateReceiverMenuItemArray_size(model->history_item_arr);
                    if(item_count > 0) {
                        if(receiver->callback) {
                            receiver->callback(
                                ProtoPirateCustomEventViewReceiverOK, receiver->context);
                        }
                    }
                },
                false);
            consumed = true;
            break;
        case InputKeyBack:
            if(receiver->callback) {
                with_view_model(
                    receiver->view,
                    ProtoPirateReceiverModel * model,
                    {
                        for(size_t i = 0;
                            i < ProtoPirateReceiverMenuItemArray_size(model->history_item_arr);
                            i++) {
                            ProtoPirateReceiverMenuItem* item =
                                ProtoPirateReceiverMenuItemArray_get(model->history_item_arr, i);
                            furi_string_free(item->item_str);
                        }
                        ProtoPirateReceiverMenuItemArray_reset(model->history_item_arr);
                        model->history_item = 0;
                        model->list_offset = 0;
                    },
                    false);
                receiver->callback(ProtoPirateCustomEventViewReceiverBack, receiver->context);
            }
            consumed = true;
            break;
        default:
            break;
        }
    }

    return consumed;
}

void protopirate_view_receiver_enter(void* context) {
    furi_assert(context);
    UNUSED(context);
}

void protopirate_view_receiver_exit(void* context) {
    furi_assert(context);
    UNUSED(context);
}

ProtoPirateReceiver* protopirate_view_receiver_alloc() {
    ProtoPirateReceiver* receiver = malloc(sizeof(ProtoPirateReceiver));

    receiver->view = view_alloc();
    view_allocate_model(receiver->view, ViewModelTypeLocking, sizeof(ProtoPirateReceiverModel));
    view_set_context(receiver->view, receiver);
    view_set_draw_callback(receiver->view, (ViewDrawCallback)protopirate_view_receiver_draw);
    view_set_input_callback(receiver->view, protopirate_view_receiver_input);
    view_set_enter_callback(receiver->view, protopirate_view_receiver_enter);
    view_set_exit_callback(receiver->view, protopirate_view_receiver_exit);

    with_view_model(
        receiver->view,
        ProtoPirateReceiverModel * model,
        {
            ProtoPirateReceiverMenuItemArray_init(model->history_item_arr);
            model->frequency_str = furi_string_alloc();
            model->preset_str = furi_string_alloc();
            model->history_stat_str = furi_string_alloc();
            model->list_offset = 0;
            model->history_item = 0;
            model->rssi = -127.0f;
            model->external_radio = false;
            model->lock = ProtoPirateLockOff;
            model->lock_count = 0;
            model->animation_frame = 0;
        },
        true);

    return receiver;
}

void protopirate_view_receiver_free(ProtoPirateReceiver* receiver) {
    furi_assert(receiver);

    with_view_model(
        receiver->view,
        ProtoPirateReceiverModel * model,
        {
            for(size_t i = 0; i < ProtoPirateReceiverMenuItemArray_size(model->history_item_arr);
                i++) {
                ProtoPirateReceiverMenuItem* item =
                    ProtoPirateReceiverMenuItemArray_get(model->history_item_arr, i);
                furi_string_free(item->item_str);
            }
            ProtoPirateReceiverMenuItemArray_clear(model->history_item_arr);
            furi_string_free(model->frequency_str);
            furi_string_free(model->preset_str);
            furi_string_free(model->history_stat_str);
        },
        false);

    view_free(receiver->view);
    free(receiver);
}

View* protopirate_view_receiver_get_view(ProtoPirateReceiver* receiver) {
    furi_assert(receiver);
    return receiver->view;
}

uint16_t protopirate_view_receiver_get_idx_menu(ProtoPirateReceiver* receiver) {
    furi_assert(receiver);
    uint16_t idx = 0;
    with_view_model(
        receiver->view, ProtoPirateReceiverModel * model, { idx = model->history_item; }, false);
    return idx;
}

void protopirate_view_receiver_set_idx_menu(ProtoPirateReceiver* receiver, uint16_t idx) {
    furi_assert(receiver);
    with_view_model(
        receiver->view,
        ProtoPirateReceiverModel * model,
        {
            model->history_item = idx;
            size_t item_count = ProtoPirateReceiverMenuItemArray_size(model->history_item_arr);
            if(model->history_item >= item_count) {
                model->history_item = item_count > 0 ? item_count - 1 : 0;
            }
        },
        true);
    protopirate_view_receiver_update_offset(receiver);
}