#include "EmulateToyPad_scene.h"

#include "../ldtoypad.h"

#include <furi.h>
#include <furi_hal.h>

/* generated by fbt from .png files in images folder */
#include <ldtoypad_icons.h>

#include <gui/elements.h>
// #include <gui/icon_i.h> // Not yet needed apparently

#include "dolphin/dolphin.h"

#include "minifigures.h"
#include "debug.h"
#include "../ToyPadEmu.h"
#include "usb/save_toypad.h"

LDToyPadApp* app;

LDToyPadSceneEmulate* toypadscene_instance;

FuriHalUsbInterface* usb_mode_prev = NULL;

struct LDToyPadSceneEmulate {
    View* view;

    FuriTimer* timer; // Timer for redrawing the screen
};

// The selected pad on the toypad
uint8_t selectedBox = 1; // Variable to keep track of which toypad box is selected

void save_current_state(ToyPadEmu* emulator) {
    if(emulator == NULL) {
        return; // Invalid emulator
    }
    if(ToyPadEmu_get_token_count() == 0) {
        set_debug_text("No tokens to save");
        return;
    }

    Token tokens_copy[MAX_TOKENS];
    for(int i = 0; i < MAX_TOKENS; i++) {
        if(emulator->tokens[i] != NULL) {
            tokens_copy[i] = *(emulator->tokens[i]);
        }
    }
    if(save_toypad(tokens_copy, boxInfo, "preset1")) {
        set_debug_text("Saved preset");
    }
}

void load_saved_state() {
    Token* tokens_loaded[MAX_TOKENS];
    BoxInfo boxes_loaded[NUM_BOXES];

    if(load_saved_toypad(tokens_loaded, boxes_loaded, "preset1")) {
        ToyPadEmu_place_tokens(tokens_loaded, boxes_loaded);
    }
}

bool ldtoypad_scene_emulate_input_callback(InputEvent* event, void* context) {
    LDToyPadSceneEmulate* instance = context;
    furi_assert(instance);

    bool consumed = false;

    static const Views submenu_selection_views[] = {
        ViewMinifigureSelection, ViewVehicleSelection, ViewFavoritesSelection, ViewSavedSelection};

    with_view_model(
        instance->view,
        LDToyPadSceneEmulateModel * model,
        {
            if(model->show_placement_selection_screen && event->type == InputTypePress) {
                if(event->key == InputKeyLeft) {
                    model->sub_screen_box_selected =
                        (model->sub_screen_box_selected + SelectionCount - 1) % SelectionCount;
                } else if(event->key == InputKeyRight) {
                    model->sub_screen_box_selected =
                        (model->sub_screen_box_selected + 1) % SelectionCount;
                } else if(event->key == InputKeyOk) {
                    view_dispatcher_switch_to_view(
                        app->view_dispatcher,
                        submenu_selection_views[model->sub_screen_box_selected]);
                }
            } else {
                // when the OK button is pressed, we want to switch to the minifigure selection screen for the selected box
                if(event->key == InputKeyOk) {
                    if(event->type == InputTypePress) {
                        model->ok_pressed = true;
                    }
                    if(event->type == InputTypeShort && model->show_mini_menu_selected) {
                        Token* index_token = ToyPadEmu_get_token(boxInfo[selectedBox].index);
                        bool isVehicle = is_vehicle(index_token);

                        switch(model->mini_option_selected) {
                        case MiniSelectionFavorite:
                            // Save the token to favorites
                            if(!isVehicle) {
                                int id = index_token->id;
                                if(id) {
                                    // check if the minifigure is already a favorite then unfavorite it
                                    if(is_favorite(id)) {
                                        if(unfavorite(id, app)) {
                                            set_debug_text("Minifigure removed from favs");
                                        } else {
                                            set_debug_text("Error removing from favs");
                                        }
                                    } else {
                                        if(favorite(id, app)) {
                                            set_debug_text("Minifigure added to favs");
                                        } else {
                                            set_debug_text("Error adding to favs");
                                        }
                                    }
                                }
                            }
                            // else {
                            //     // TODO: Implement vehicle favorites
                            // }
                            break;
                        case MiniSelectionSave:
                            if(isVehicle) {
                                save_token(index_token);

                                fill_saved_submenu(app);
                            }
                            break;
                        default:
                            break;
                        }

                        model->show_mini_menu_selected = false;
                        model->ok_pressed = false;
                        return true;
                    } else if(
                        event->type == InputTypeLong && model->connected &&
                        boxInfo[selectedBox].isFilled) {
                        model->show_mini_menu_selected = !model->show_mini_menu_selected;
                    } else if(event->type == InputTypeShort && model->connected) {
                        if(boxInfo[selectedBox].isFilled) {
                            // if the box is filled, we want to remove the minifigure from the selected box
                            int i = boxInfo[selectedBox].index;
                            if(i >= 0 && ToyPadEmu_remove(i)) {
                                boxInfo[selectedBox].isFilled = false;
                                boxInfo[selectedBox].index = -1; // Reset index
                                set_debug_text("Going to remove minifig from toypad");
                                consumed = true;
                            }
                            return consumed;
                        } else {
                            // if the current selected box is not filled, we want to switch to the minifigure selection screen

                            // set current view to minifigure / vehicle selection screen
                            model->show_placement_selection_screen = true;

                            if(model->minifig_only_mode) {
                                view_dispatcher_switch_to_view(
                                    app->view_dispatcher, ViewMinifigureSelection);
                            }
                        }
                    } else if(event->type == InputTypeRelease) {
                        model->ok_pressed = false;
                    }
                }
                if((event->key == InputKeyLeft || event->key == InputKeyRight) &&
                   model->show_mini_menu_selected) {
                    model->show_mini_menu_selected = false;
                }

                if(event->type == InputTypeLong && model->connected) {
                    switch(event->key) {
                    case InputKeyUp:
                        save_current_state(emulator);
                        break;
                    case InputKeyDown:
                        load_saved_state();
                        // view_dispatcher_switch_to_view(app->view_dispatcher, ViewFileBrowser);
                        // return true;
                        break;
                    case InputKeyBack:
                        model->back_long_pressed = true;
                        ToyPadEmu_remove_all_tokens(emulator);
                        break;
                    default:
                        break;
                    }
                }
                if(event->key == InputKeyBack && event->type == InputTypeRelease) {
                    model->back_long_pressed = false;
                }

                if(model->show_mini_menu_selected && event->type == InputTypePress) {
                    if(event->key == InputKeyUp) {
                        model->mini_option_selected =
                            (model->mini_option_selected + MiniSelectionCount - 1) %
                            MiniSelectionCount;
                        return true;
                    } else if(event->key == InputKeyDown) {
                        model->mini_option_selected =
                            (model->mini_option_selected + 1) % MiniSelectionCount;
                        return true;
                    }
                }

                // make user loop through boxes with InputKeyLeft, InputKeyRight, InputKeyUp, InputKeyDown
                switch(event->key) {
                case InputKeyLeft:
                    if(event->type == InputTypePress) {
                        model->left_pressed = true;
                        if(selectedBox == 0) {
                            selectedBox = NUM_BOXES;
                        }
                        selectedBox--;
                    } else if(event->type == InputTypeRelease) {
                        model->left_pressed = false;
                    }
                    break;
                case InputKeyRight:
                    if(event->type == InputTypePress) {
                        model->right_pressed = true;
                        selectedBox++;
                        if(selectedBox >= NUM_BOXES) {
                            selectedBox = 0;
                        }
                    } else if(event->type == InputTypeRelease) {
                        model->right_pressed = false;
                    }
                    break;
                case InputKeyUp:
                    if(event->type == InputTypePress) {
                        model->up_pressed = true;
                        if(selectedBox == 0) {
                            selectedBox = 3;
                        } else if(selectedBox >= 4) {
                            selectedBox -= 4;
                        } else {
                            selectedBox = (NUM_BOXES - 3) + selectedBox;
                        }
                        if(selectedBox >= NUM_BOXES) {
                            selectedBox = 0;
                        }
                    } else if(event->type == InputTypeRelease) {
                        model->up_pressed = false;
                    }
                    break;
                case InputKeyDown:
                    if(event->type == InputTypePress) {
                        model->down_pressed = true;
                        if(selectedBox == 2) {
                            selectedBox = 6;
                        } else if(selectedBox == 3) {
                            selectedBox = 0;
                        } else if(selectedBox == 5) {
                            selectedBox = 2;
                        } else if(selectedBox < (NUM_BOXES - 3)) {
                            selectedBox += 3;
                        } else {
                            selectedBox = selectedBox - (NUM_BOXES - 3);
                        }
                    } else if(event->type == InputTypeRelease) {
                        model->down_pressed = false;
                    }
                    break;
                default:
                    break;
                }
            }
        },
        true);

    return consumed;
}

static const char* all_mini_menu_labels[] = {"Add favorite", "Save vehicle"};

static void ldtoypad_scene_emulate_draw_render_callback(Canvas* canvas, void* context) {
    LDToyPadSceneEmulateModel* model = context;

    if(model->show_placement_selection_screen) {
        draw_placement_selection_screen(canvas, model->sub_screen_box_selected);
        return;
    }

    // when the usb device is not set in modek, set it
    if(model->usbDevice == NULL) {
        model->usbDevice = get_usb_device();
    }

    if(get_connected_status() == ConnectedStatusCleanupWanted) {
        ToyPadEmu_clear(); // Clear the emulator if the USB is disconnected, this needs to be here because I cannot call this from the USB's ISR context.
        set_connected_status(
            ConnectedStatusDisconnected); // Set the connected status to 0 (disconnected)
    }
    if(get_connected_status() == ConnectedStatusReconnecting) {
        model->connected = true;
        set_connected_status(
            ConnectedStatusConnected); // Set the connected status to 1 (connected) and not 2 (re-connecting)
        model->connection_status = "USB Awoken";
        model->sub_screen_box_selected =
            SelectionMinifigure; // Set the minifigure box selected as this is the most commonnly used at start of the app.

        // reset the filled boxes
        ToyPadEmu_clear();

        // Give dolphin some xp for connecting the toypad
        dolphin_deed(DolphinDeedPluginStart);

        if(toypadscene_instance->timer != NULL) {
            furi_timer_stop(toypadscene_instance->timer);
            furi_timer_start(toypadscene_instance->timer, furi_ms_to_ticks(5000));
        }
    } else if(model->connected) {
        model->connection_status = "USB Connected";
    } else if(!model->connected) {
        model->connection_status = "Trying to connect USB";
    }

    if((model->selected_minifigure_index > 0 || model->selected_vehicle_index > 0) &&
       model->connected) {
        int id = model->selected_minifigure_index > 0 ? model->selected_minifigure_index :
                                                        model->selected_vehicle_index;

        bool is_vehicle = (model->selected_vehicle_index > 0);

        if(is_vehicle) {
            model->selected_vehicle_index = 0;
        } else {
            model->selected_minifigure_index = 0;
        }

        if(!is_vehicle && id < 1) id = 1;
        if(is_vehicle && id < 1000) id = 1000;

        Token* token = is_vehicle ? createVehicle(id, (uint32_t[]){0, 0}) : createCharacter(id);
        if(!token) return; // Handle allocation failure

        ToyPadEmu_place(token, selectedBox);
    }

    canvas_clear(canvas);
    canvas_set_font(canvas, FontPrimary);

    // Draw the big toypad image as decoration for the background of the screen
    canvas_draw_icon(canvas, 10, 13, &I_toypad);

    // Get position for the selected box
    uint8_t x = boxInfo[selectedBox].x;
    uint8_t y = boxInfo[selectedBox].y;

    // Check if the selectedBox is 1 (circle) and draw the circle.
    if(selectedBox == 1) {
        canvas_draw_icon(canvas, x, y, &I_circle);
    } else {
        canvas_draw_icon(canvas, x, y, &I_box);
    }

    int token_selected = 0;

    // when the box is filled, draw the minifigure icon
    for(int i = 0; i < NUM_BOXES; i++) {
        if(boxInfo[i].isFilled) {
            Token* token = emulator->tokens[boxInfo[i].index];
            if(model->show_icons_index) {
                if(is_minifig(
                       token)) { // Only minifigures have an id, vehicles have no id, but is stored in the "token[180]"
                    // Draw the minifigure icon
                    canvas_draw_icon(canvas, boxInfo[i].x + 4, boxInfo[i].y + 3, &I_head);
                } else {
                    // Draw the vehicle icon
                    canvas_draw_icon(canvas, boxInfo[i].x + 4, boxInfo[i].y + 3, &I_car);
                }
            } else {
                // Draw the first letter of the minifigure name
                char letter[1] = {0};

                // Find the first letter that is not '*' or space
                for(char* p = token->name; *p; p++) {
                    if(*p != '*' && *p != ' ') {
                        letter[0] = *p;
                        break;
                    }
                }

                canvas_draw_str(canvas, boxInfo[i].x + 6, boxInfo[i].y + 12, letter);
            }

            // Set the connection status text to the currently connected minifigure name
            if(selectedBox == i) {
                model->connection_status = token->name;

                if(is_minifig(token)) {
                    token_selected = 1;
                } else {
                    // vehicles dont have an id stored in token->id, but in token[180]
                    token_selected = 2;
                }
            }
        }
    }

    if(token_selected == 1) {
        canvas_draw_icon(canvas, 0, 0, &I_head);
    } else if(token_selected == 2) {
        canvas_draw_icon(canvas, 0, 0, &I_car);
    }
    if(token_selected) {
        elements_multiline_text_aligned(
            canvas, 15, 1, AlignLeft, AlignTop, model->connection_status);
    } else {
        elements_multiline_text_aligned(
            canvas, 1, 1, AlignLeft, AlignTop, model->connection_status);
    }

    if(model->show_debug_text_index) {
        canvas_set_color(canvas, ColorWhite);
        canvas_draw_box(canvas, 0, 16, 120, 20);
        canvas_set_color(canvas, ColorBlack);

        elements_multiline_text_aligned(canvas, 1, 17, AlignLeft, AlignTop, "Debug: ");
        elements_multiline_text_aligned(canvas, 40, 17, AlignLeft, AlignTop, get_debug_text());
    }

    if(model->show_mini_menu_selected && model->connected && token_selected) {
        // Adjust position depending on selectedBox
        // TODO: Needs to be looked at if positions are good for all boxes
        if(selectedBox == 2 || selectedBox == 6) {
            x -= 75;
            y += 10;
        } else if(selectedBox == 1) {
            x -= 5;
            y += 5;
        } else {
            x += 20;
            y += 10;
        }

        // Determine which menu items to show
        const char* visible_labels[2];
        int visible_count = 0;

        if(token_selected == 1) {
            // Only minifig, show Add favorite
            visible_labels[visible_count++] = all_mini_menu_labels[0];

            // change add favorite to remove favorite if the minifigure is already a favorite
            if(is_favorite(ToyPadEmu_get_token(boxInfo[selectedBox].index)->id)) {
                visible_labels[0] = "Remove favorite";
            }
        } else if(token_selected == 2) {
            // Only vehicle, show only save vehicle
            visible_labels[visible_count++] = all_mini_menu_labels[1];
            model->mini_option_selected = MiniSelectionSave;
        }

        // Draw visible menu
        for(int i = 0; i < visible_count; i++) {
            // Currently only one label is shown, so no need to change font depending on selection
            canvas_set_font(canvas, FontPrimary);

            elements_multiline_text_framed(
                canvas,
                x,
                y + i * 12, // vertical spacing
                visible_labels[i]);
        }

        canvas_set_font(canvas, FontPrimary);
    }

    if(!model->connected && model->ok_pressed) {
        // when boxes at the right side of the screen are pressed, show message at the left side
        if(selectedBox == 2 || selectedBox == 6) {
            x -= 75;
            y += 10;
        } else if(selectedBox == 1) {
            x -= 30;
            y += 22;
        } else {
            x += 20;
            y += 10;
        }

        elements_multiline_text_framed(canvas, x, y, "Connect Game");
    }
}

static uint32_t ldtoypad_scene_emulate_navigation_submenu_callback(void* context) {
    UNUSED(context);

    with_view_model(
        ldtoypad_scene_emulate_get_view(toypadscene_instance),
        LDToyPadSceneEmulateModel * model,
        {
            if(model->show_placement_selection_screen) {
                model->show_placement_selection_screen = false;
                return ViewEmulate;
            }

            if(model->show_mini_menu_selected) {
                model->show_mini_menu_selected = false;
                return ViewEmulate;
            }

            if(model->back_long_pressed) {
                model->back_long_pressed = false;
                return ViewEmulate;
            }
        },
        true);

    return ViewSubmenu;
}

void ldtoypad_scene_emulate_view_game_timer_callback(void* context) {
    UNUSED(context);
    view_dispatcher_send_custom_event(get_view_dispatcher(), 0);
}

void ldtoypad_scene_emulate_enter_callback(void* context) {
    uint32_t period = furi_ms_to_ticks(200);
    LDToyPadSceneEmulate* app = (LDToyPadSceneEmulate*)context;
    furi_assert(app->timer == NULL);
    app->timer = furi_timer_alloc(
        ldtoypad_scene_emulate_view_game_timer_callback, FuriTimerTypePeriodic, app);
    furi_timer_start(app->timer, period);
}

void ldtoypad_scene_emulate_exit_callback(void* context) {
    LDToyPadSceneEmulate* app = (LDToyPadSceneEmulate*)context;
    furi_timer_stop(app->timer);
    furi_timer_free(app->timer);
    app->timer = NULL;
}

static bool ldtoypad_scene_emulate_custom_event_callback(uint32_t event, void* context) {
    LDToyPadSceneEmulate* scene = (LDToyPadSceneEmulate*)context;
    switch(event) {
    case 0:
        // Redraw screen by passing true to last parameter of with_view_model.
        {
            bool redraw = true;
            with_view_model(
                ldtoypad_scene_emulate_get_view(scene),
                LDToyPadSceneEmulateModel * _model,
                { UNUSED(_model); },
                redraw);
            return true;
        }
    default:
        return false;
    }
}

LDToyPadSceneEmulate* ldtoypad_scene_emulate_alloc(LDToyPadApp* new_app) {
    furi_assert(new_app);
    app = new_app;

    if(emulator == NULL) emulator = malloc(sizeof(ToyPadEmu));
    memset(emulator->tokens, 0, sizeof(emulator->tokens));

    LDToyPadSceneEmulate* instance = malloc(sizeof(LDToyPadSceneEmulate));
    instance->view = view_alloc();

    toypadscene_instance = instance;

    // ldtoypad_view_dispatcher = view_dispatcher;

    usb_mode_prev = furi_hal_usb_get_config();

    furi_hal_usb_unlock();
    furi_check(furi_hal_usb_set_config(&usb_hid_ldtoypad, NULL) == true);

    view_set_context(instance->view, instance);
    view_allocate_model(instance->view, ViewModelTypeLockFree, sizeof(LDToyPadSceneEmulateModel));
    // view_set_draw_callback(instance->view, ldtoypad_scene_emulate_draw_callback);
    view_set_draw_callback(instance->view, ldtoypad_scene_emulate_draw_render_callback);
    view_set_input_callback(instance->view, ldtoypad_scene_emulate_input_callback);

    view_set_previous_callback(instance->view, ldtoypad_scene_emulate_navigation_submenu_callback);

    view_set_enter_callback(instance->view, ldtoypad_scene_emulate_enter_callback);
    view_set_exit_callback(instance->view, ldtoypad_scene_emulate_exit_callback);

    view_set_custom_callback(instance->view, ldtoypad_scene_emulate_custom_event_callback);

    return instance;
}

void ldtoypad_scene_emulate_free(LDToyPadSceneEmulate* ldtoypad_emulate_view) {
    furi_assert(ldtoypad_emulate_view);
    view_free(ldtoypad_emulate_view->view);

    // Change back profile
    if(usb_mode_prev != NULL) {
        furi_hal_usb_set_config(usb_mode_prev, NULL);
    }

    free(ldtoypad_emulate_view);
}

View* ldtoypad_scene_emulate_get_view(LDToyPadSceneEmulate* instance) {
    furi_assert(instance);
    return instance->view;
}

void saved_token_submenu_callback(void* context, uint32_t index) {
    UNUSED(index);
    // get file path from the context char file_path
    FuriString* filepath = (FuriString*)context;

    if(furi_string_utf8_length(filepath) == 0) {
        set_debug_text("Invalid filepath");
        return;
    }

    set_debug_text((char*)furi_string_get_cstr(filepath));

    // Load the token from the file
    Token* token = load_saved_token((char*)furi_string_get_cstr(filepath));
    if(token == NULL) {
        return;
    }

    with_view_model(
        ldtoypad_scene_emulate_get_view(app->view_scene_emulate),
        LDToyPadSceneEmulateModel * model,
        {
            model->selected_minifigure_index = 0;
            model->selected_vehicle_index = 0;
            if(model->connected) {
                // set the token to the selected index
                Token* token = load_saved_token((char*)furi_string_get_cstr(filepath));
                if(token != NULL) {
                    ToyPadEmu_place(token, selectedBox);
                }
            }
            model->show_placement_selection_screen = false;
        },
        true);

    view_dispatcher_switch_to_view(app->view_dispatcher, ViewEmulate);
}

void minifigures_submenu_callback(void* context, uint32_t index) {
    LDToyPadApp* app = (LDToyPadApp*)context;

    // set current view to minifigure number to the selected index
    with_view_model(
        ldtoypad_scene_emulate_get_view(app->view_scene_emulate),
        LDToyPadSceneEmulateModel * model,
        {
            model->selected_vehicle_index = 0;
            if(model->connected) {
                model->selected_minifigure_index = index;
            }
            model->show_placement_selection_screen = false;
        },
        true);

    view_dispatcher_switch_to_view(app->view_dispatcher, ViewEmulate);
}

void vehicles_submenu_callback(void* context, uint32_t index) {
    LDToyPadApp* app = (LDToyPadApp*)context;

    // set current view to minifigure number to the selected index
    with_view_model(
        ldtoypad_scene_emulate_get_view(app->view_scene_emulate),
        LDToyPadSceneEmulateModel * model,
        {
            model->selected_minifigure_index = 0;
            if(model->connected) {
                model->selected_vehicle_index = index;
            }
            model->show_placement_selection_screen = false;
        },
        true);

    view_dispatcher_switch_to_view(app->view_dispatcher, ViewEmulate);
}
